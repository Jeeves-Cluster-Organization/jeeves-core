<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 72px;
}
.code-line {
  margin: 0;
  height: 1em;
  counter-increment: line;

  position: absolute;
  padding: 0 0.3em 0.3em 0.3em;
  display: inherit;
  width: 100%;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

.code-text-container {
  position: relative;
  height: 1em;
  padding: 0.3em 0;
}

.cover-indicator {
  display: flex;
  width: 100%;
  position: absolute;
  justify-content: end;
  height: 1em;
  align-items: center;
  padding: 0 0.3em 0.3em 0.3em;
}

.cover-indicator.check-cover::after {
  content: "\2713";
  font-weight: bold;
  background-color: var(--green);
  height: 1em;
}

.cover-indicator.no-cover::after {
  content: "\2716";
  font-weight: bold;
  background-color: var(--red);
  height: 1em;
}

.stat-line-hit {
  max-width: 48px;
  overflow: hidden;
  font-weight: bold;
  margin-right: 4px;
  background-color: var(--green);
  position: relative;
  top: 0.1em;
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","user","jeeves-core","build.rs"],"content":"fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let proto_file = \"coreengine/proto/engine.proto\";\n\n    println!(\"cargo:rerun-if-changed={}\", proto_file);\n\n    // Configure tonic code generation (outputs to OUT_DIR by default)\n    tonic_build::configure()\n        .build_server(true)\n        .build_client(true)\n        .compile_protos(\u0026[proto_file], \u0026[\"coreengine/proto\"])?;\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","jeeves-core","src","commbus","mod.rs"],"content":"//! Communication bus for pub/sub and request/response patterns.\n\n/// CommBus (checkpoint 7 - stub for now).\n#[derive(Debug)]\npub struct CommBus {\n    // Message bus will be implemented in checkpoint 7\n}\n\nimpl CommBus {\n    pub fn new() -\u003e Self {\n        Self {}\n    }\n}\n\nimpl Default for CommBus {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","jeeves-core","src","envelope","enums.rs"],"content":"//! Core enumerations for envelope and kernel.\n//!\n//! These are the source of truth, matching Go's envelope/enums.go.\n\nuse serde::{Deserialize, Serialize};\n\n/// Why processing terminated (matches proto TerminalReason exactly).\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum TerminalReason {\n    Completed,\n    MaxIterationsExceeded,\n    MaxLlmCallsExceeded,\n    MaxAgentHopsExceeded,\n    UserCancelled,\n    ToolFailedFatally,\n    LlmFailedFatally,\n    PolicyViolation,\n}\n\n/// Interrupt type.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum InterruptKind {\n    Clarification,\n    Confirmation,\n    AgentReview,\n    Checkpoint,\n    ResourceExhausted,\n    Timeout,\n    SystemError,\n}\n\n/// Risk level for tool execution.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum RiskLevel {\n    // Semantic\n    ReadOnly,\n    Write,\n    Destructive,\n    // Severity\n    Low,\n    Medium,\n    High,\n    Critical,\n}\n\nimpl RiskLevel {\n    pub fn requires_confirmation(self) -\u003e bool {\n        matches!(\n            self,\n            RiskLevel::Destructive | RiskLevel::High | RiskLevel::Critical\n        )\n    }\n}\n\n/// Tool category.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum ToolCategory {\n    // Operation types\n    Read,\n    Write,\n    Execute,\n    Network,\n    System,\n    // Organization\n    Unified,\n    Composite,\n    Resilient,\n    Standalone,\n    Internal,\n}\n\n/// Health status.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum HealthStatus {\n    Healthy,\n    Degraded,\n    Unhealthy,\n    Unknown,\n}\n\n/// Loop control verdict.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum LoopVerdict {\n    Proceed,\n    LoopBack,\n    Advance,\n    Escalate,\n}\n\n/// Risk approval status.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum RiskApproval {\n    Approved,\n    Denied,\n    Pending,\n}\n\n/// Tool access level.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum ToolAccess {\n    None,\n    Read,\n    Write,\n    All,\n}\n\n/// Operation result status.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum OperationStatus {\n    Success,\n    Error,\n    NotFound,\n    Timeout,\n    ValidationError,\n    Partial,\n    InvalidParameters,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","jeeves-core","src","envelope","export.rs"],"content":"//! Envelope export to JSON.\n//!\n//! Infallible serialization using serde.\n\n/// Export envelope to JSON bytes (checkpoint 2 - stub for now).\npub fn to_json(_envelope: \u0026super::Envelope) -\u003e Vec\u003cu8\u003e {\n    // TODO: Implement in checkpoint 2\n    unimplemented!(\"to_json will be implemented in checkpoint 2\")\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","jeeves-core","src","envelope","import.rs"],"content":"//! Envelope import from JSON (Go compatibility layer).\n//!\n//! This module handles deserialization of envelope state from Go-produced JSON,\n//! including normalization of legacy artifacts (null → {}, float → int, etc.).\n\nuse serde::Deserialize;\n\n/// Import envelope from JSON bytes (checkpoint 2 - stub for now).\npub fn from_json(_bytes: \u0026[u8]) -\u003e crate::types::Result\u003csuper::Envelope\u003e {\n    // TODO: Implement in checkpoint 2\n    unimplemented!(\"from_json will be implemented in checkpoint 2\")\n}\n\n/// Custom deserializer for int fields encoded as floats in JSON.\npub fn deserialize_int_from_float\u003c'de, D\u003e(deserializer: D) -\u003e Result\u003cu32, D::Error\u003e\nwhere\n    D: serde::Deserializer\u003c'de\u003e,\n{\n    let f: f64 = f64::deserialize(deserializer)?;\n    if f.fract() != 0.0 {\n        return Err(serde::de::Error::custom(\"non-integer float\"));\n    }\n    Ok(f as u32)\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","user","jeeves-core","src","envelope","mod.rs"],"content":"//! Envelope - the core state container.\n//!\n//! The Envelope represents the mutable state of a request as it flows through\n//! the multi-agent pipeline. It tracks inputs, outputs, bounds, and interrupts.\n//!\n//! This is a direct port of Go's envelope.go with dynamic `Outputs` map for\n//! flexible agent architecture.\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\npub mod enums;\npub mod export;\npub mod import;\n\npub use enums::*;\n\n/// Response to a flow interrupt.\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct InterruptResponse {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub text: Option\u003cString\u003e,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub approved: Option\u003cbool\u003e,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub decision: Option\u003cString\u003e,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub data: Option\u003cHashMap\u003cString, serde_json::Value\u003e\u003e,\n\n    pub received_at: DateTime\u003cUtc\u003e,\n}\n\n/// Flow interrupt (clarification, confirmation, etc.).\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct FlowInterrupt {\n    pub kind: InterruptKind,\n    pub id: String,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub question: Option\u003cString\u003e,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub message: Option\u003cString\u003e,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub data: Option\u003cHashMap\u003cString, serde_json::Value\u003e\u003e,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub response: Option\u003cInterruptResponse\u003e,\n\n    pub created_at: DateTime\u003cUtc\u003e,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub expires_at: Option\u003cDateTime\u003cUtc\u003e\u003e,\n}\n\nimpl FlowInterrupt {\n    pub fn new(kind: InterruptKind) -\u003e Self {\n        Self {\n            kind,\n            id: format!(\"int_{}\", uuid::Uuid::new_v4().simple().to_string()[..16].to_string()),\n            question: None,\n            message: None,\n            data: None,\n            response: None,\n            created_at: Utc::now(),\n            expires_at: None,\n        }\n    }\n\n    pub fn with_question(mut self, q: String) -\u003e Self {\n        self.question = Some(q);\n        self\n    }\n\n    pub fn with_message(mut self, m: String) -\u003e Self {\n        self.message = Some(m);\n        self\n    }\n\n    pub fn with_data(mut self, d: HashMap\u003cString, serde_json::Value\u003e) -\u003e Self {\n        self.data = Some(d);\n        self\n    }\n\n    pub fn with_expiry(mut self, duration: std::time::Duration) -\u003e Self {\n        self.expires_at = Some(Utc::now() + chrono::Duration::from_std(duration).unwrap_or_default());\n        self\n    }\n}\n\n/// Processing record for audit trail.\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct ProcessingRecord {\n    pub agent: String,\n    pub stage_order: i32,\n    pub started_at: DateTime\u003cUtc\u003e,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub completed_at: Option\u003cDateTime\u003cUtc\u003e\u003e,\n\n    pub duration_ms: i32,\n    pub status: String, // \"running\", \"success\", \"error\", \"skipped\"\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub error: Option\u003cString\u003e,\n\n    pub llm_calls: i32,\n}\n\n/// Main envelope structure.\n///\n/// Unlike hardcoded per-agent output fields, Envelope uses a dynamic `Outputs` map\n/// where any agent can write results keyed by agent name.\n///\n/// Example (pseudo-code):\n/// ```ignore\n/// envelope.outputs.insert(\"perception\", {...});\n/// envelope.outputs.insert(\"intent\", {...});\n/// ```\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct Envelope {\n    // ===== Identification =====\n    pub envelope_id: String,\n    pub request_id: String,\n    pub user_id: String,\n    pub session_id: String,\n\n    // ===== Original Input =====\n    pub raw_input: String,\n    pub received_at: DateTime\u003cUtc\u003e,\n\n    // ===== Dynamic Agent Outputs =====\n    /// Outputs from agents: map[agent_name] = map[output_key] = value\n    pub outputs: HashMap\u003cString, HashMap\u003cString, serde_json::Value\u003e\u003e,\n\n    // ===== Pipeline State (string-based, not enum) =====\n    pub current_stage: String,\n    pub stage_order: Vec\u003cString\u003e,\n    pub iteration: i32,\n    pub max_iterations: i32,\n\n    // ===== Parallel Execution State =====\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub active_stages: Option\u003cHashMap\u003cString, bool\u003e\u003e,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub completed_stage_set: Option\u003cHashMap\u003cString, bool\u003e\u003e,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub failed_stages: Option\u003cHashMap\u003cString, String\u003e\u003e,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub parallel_mode: Option\u003cbool\u003e,\n\n    // ===== Bounds Tracking =====\n    pub llm_call_count: i32,\n    pub max_llm_calls: i32,\n    pub tool_call_count: i32,\n    pub agent_hop_count: i32,\n    pub max_agent_hops: i32,\n    pub tokens_in: i64,\n    pub tokens_out: i64,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub terminal_reason: Option\u003cTerminalReason\u003e,\n\n    // ===== Control Flow =====\n    pub terminated: bool,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub termination_reason: Option\u003cString\u003e,\n\n    // ===== Unified Interrupt Handling =====\n    pub interrupt_pending: bool,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub interrupt: Option\u003cFlowInterrupt\u003e,\n\n    // ===== Multi-Stage Execution =====\n    pub completed_stages: Vec\u003cHashMap\u003cString, serde_json::Value\u003e\u003e,\n    pub current_stage_number: i32,\n    pub max_stages: i32,\n    pub all_goals: Vec\u003cString\u003e,\n    pub remaining_goals: Vec\u003cString\u003e,\n    pub goal_completion_status: HashMap\u003cString, String\u003e,\n\n    // ===== Retry Context =====\n    pub prior_plans: Vec\u003cHashMap\u003cString, serde_json::Value\u003e\u003e,\n    pub loop_feedback: Vec\u003cString\u003e,\n\n    // ===== Audit Trail =====\n    pub processing_history: Vec\u003cProcessingRecord\u003e,\n    pub errors: Vec\u003cHashMap\u003cString, serde_json::Value\u003e\u003e,\n\n    // ===== Timing =====\n    pub created_at: DateTime\u003cUtc\u003e,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub completed_at: Option\u003cDateTime\u003cUtc\u003e\u003e,\n\n    // ===== Metadata =====\n    pub metadata: HashMap\u003cString, serde_json::Value\u003e,\n}\n\nimpl Envelope {\n    /// Create a new envelope with default values (matches Go's NewEnvelope).\n    pub fn new() -\u003e Self {\n        let now = Utc::now();\n        let uuid_short = || uuid::Uuid::new_v4().simple().to_string()[..16].to_string();\n\n        Self {\n            // Identification\n            envelope_id: format!(\"env_{}\", uuid_short()),\n            request_id: format!(\"req_{}\", uuid_short()),\n            user_id: \"anonymous\".to_string(),\n            session_id: format!(\"sess_{}\", uuid_short()),\n\n            // Input\n            raw_input: String::new(),\n            received_at: now,\n\n            // Outputs\n            outputs: HashMap::new(),\n\n            // Pipeline state\n            current_stage: \"start\".to_string(),\n            stage_order: Vec::new(),\n            iteration: 0,\n            max_iterations: 3,\n\n            // Parallel execution\n            active_stages: Some(HashMap::new()),\n            completed_stage_set: Some(HashMap::new()),\n            failed_stages: Some(HashMap::new()),\n            parallel_mode: Some(false),\n\n            // Bounds\n            llm_call_count: 0,\n            max_llm_calls: 10,\n            tool_call_count: 0,\n            agent_hop_count: 0,\n            max_agent_hops: 21,\n            tokens_in: 0,\n            tokens_out: 0,\n            terminal_reason: None,\n\n            // Control flow\n            terminated: false,\n            termination_reason: None,\n\n            // Interrupts\n            interrupt_pending: false,\n            interrupt: None,\n\n            // Multi-stage\n            completed_stages: Vec::new(),\n            current_stage_number: 1,\n            max_stages: 5,\n            all_goals: Vec::new(),\n            remaining_goals: Vec::new(),\n            goal_completion_status: HashMap::new(),\n\n            // Retry\n            prior_plans: Vec::new(),\n            loop_feedback: Vec::new(),\n\n            // Audit\n            processing_history: Vec::new(),\n            errors: Vec::new(),\n\n            // Timing\n            created_at: now,\n            completed_at: None,\n\n            // Metadata\n            metadata: HashMap::new(),\n        }\n    }\n\n    /// Start a stage (mark as actively executing).\n    pub fn start_stage(\u0026mut self, stage_name: impl Into\u003cString\u003e) {\n        if self.active_stages.is_none() {\n            self.active_stages = Some(HashMap::new());\n        }\n        if let Some(ref mut stages) = self.active_stages {\n            stages.insert(stage_name.into(), true);\n        }\n    }\n\n    /// Complete a stage successfully.\n    pub fn complete_stage(\u0026mut self, stage_name: \u0026str) {\n        if self.completed_stage_set.is_none() {\n            self.completed_stage_set = Some(HashMap::new());\n        }\n        if let Some(ref mut completed) = self.completed_stage_set {\n            completed.insert(stage_name.to_string(), true);\n        }\n        if let Some(ref mut active) = self.active_stages {\n            active.remove(stage_name);\n        }\n    }\n\n    /// Mark a stage as failed.\n    pub fn fail_stage(\u0026mut self, stage_name: impl Into\u003cString\u003e, error_msg: impl Into\u003cString\u003e) {\n        let stage_name_str = stage_name.into();\n        if self.failed_stages.is_none() {\n            self.failed_stages = Some(HashMap::new());\n        }\n        if let Some(ref mut failed) = self.failed_stages {\n            failed.insert(stage_name_str.clone(), error_msg.into());\n        }\n        if let Some(ref mut active) = self.active_stages {\n            active.remove(\u0026stage_name_str);\n        }\n    }\n\n    /// Check if a stage is completed.\n    pub fn is_stage_completed(\u0026self, stage_name: \u0026str) -\u003e bool {\n        self.completed_stage_set\n            .as_ref()\n            .and_then(|s| s.get(stage_name))\n            .copied()\n            .unwrap_or(false)\n    }\n\n    /// Check if a stage failed.\n    pub fn is_stage_failed(\u0026self, stage_name: \u0026str) -\u003e bool {\n        self.failed_stages\n            .as_ref()\n            .and_then(|s| s.get(stage_name))\n            .is_some()\n    }\n\n    /// Check if at any bound limit.\n    pub fn at_limit(\u0026self) -\u003e bool {\n        self.llm_call_count \u003e= self.max_llm_calls || self.agent_hop_count \u003e= self.max_agent_hops\n    }\n\n    /// Increment LLM call counter.\n    pub fn increment_llm_calls(\u0026mut self, count: i32) {\n        self.llm_call_count += count;\n    }\n\n    /// Increment agent hop counter.\n    pub fn increment_agent_hops(\u0026mut self) {\n        self.agent_hop_count += 1;\n    }\n\n    /// Add processing record to history.\n    pub fn add_processing_record(\u0026mut self, record: ProcessingRecord) {\n        self.processing_history.push(record);\n    }\n\n    /// Terminate envelope with reason.\n    pub fn terminate(\u0026mut self, reason: impl Into\u003cString\u003e) {\n        self.terminated = true;\n        self.termination_reason = Some(reason.into());\n        self.completed_at = Some(Utc::now());\n    }\n\n    /// Set interrupt pending.\n    pub fn set_interrupt(\u0026mut self, interrupt: FlowInterrupt) {\n        self.interrupt_pending = true;\n        self.interrupt = Some(interrupt);\n    }\n\n    /// Clear interrupt.\n    pub fn clear_interrupt(\u0026mut self) {\n        self.interrupt_pending = false;\n        self.interrupt = None;\n    }\n}\n\nimpl Default for Envelope {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[{"line":62,"address":[5883568,5884608],"length":1,"stats":{"Line":1}},{"line":65,"address":[5884393,5883591,5883823,5884021,5884582],"length":1,"stats":{"Line":3}},{"line":70,"address":[5884062],"length":1,"stats":{"Line":1}},{"line":80,"address":[5880193],"length":1,"stats":{"Line":0}},{"line":81,"address":[5880152,5879370,5879334],"length":1,"stats":{"Line":2}},{"line":82,"address":[5879404],"length":1,"stats":{"Line":1}},{"line":212,"address":[5884624,5887194],"length":1,"stats":{"Line":1}},{"line":213,"address":[5884646],"length":1,"stats":{"Line":1}},{"line":214,"address":[5965533,5965153,5965136,5965353,5965385],"length":1,"stats":{"Line":4}},{"line":218,"address":[5884665,5887181,5884830],"length":1,"stats":{"Line":2}},{"line":219,"address":[5884849,5885016,5887150],"length":1,"stats":{"Line":2}},{"line":220,"address":[5885022],"length":1,"stats":{"Line":1}},{"line":221,"address":[5885228,5887101,5885061],"length":1,"stats":{"Line":2}},{"line":231,"address":[5885329],"length":1,"stats":{"Line":1}},{"line":232,"address":[5885363],"length":1,"stats":{"Line":1}},{"line":237,"address":[5885389],"length":1,"stats":{"Line":1}},{"line":238,"address":[5885441],"length":1,"stats":{"Line":1}},{"line":239,"address":[5885492],"length":1,"stats":{"Line":1}},{"line":264,"address":[5885607],"length":1,"stats":{"Line":1}},{"line":265,"address":[5885621],"length":1,"stats":{"Line":1}},{"line":266,"address":[5885632],"length":1,"stats":{"Line":1}},{"line":270,"address":[5885682],"length":1,"stats":{"Line":1}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}}],"covered":21,"coverable":39},{"path":["/","home","user","jeeves-core","src","kernel","interrupts.rs"],"content":"//! Interrupt handling - unified interrupt service.\n//!\n//! Features:\n//!   - Create and resolve interrupts\n//!   - Pending interrupt queue per request/session\n//!   - Interrupt lifecycle management\n//!   - Config-driven behavior per interrupt kind\n\nuse crate::envelope::{FlowInterrupt, InterruptKind, InterruptResponse};\nuse chrono::{DateTime, Duration, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n// =============================================================================\n// Interrupt Status\n// =============================================================================\n\n/// Status of an interrupt.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum InterruptStatus {\n    /// Interrupt is awaiting response\n    Pending,\n    /// Interrupt has been resolved\n    Resolved,\n    /// Interrupt has expired\n    Expired,\n    /// Interrupt was cancelled\n    Cancelled,\n}\n\n// =============================================================================\n// Interrupt Config\n// =============================================================================\n\n/// Configuration for a specific interrupt kind.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct InterruptConfig {\n    /// Default time-to-live for interrupts of this kind. None means no expiry.\n    pub default_ttl: Option\u003cDuration\u003e,\n    /// Determines if pending interrupts should auto-expire\n    pub auto_expire: bool,\n    /// Determines if a response is required to resolve\n    pub require_response: bool,\n}\n\nimpl InterruptConfig {\n    /// Default configuration for an interrupt kind.\n    pub fn default_for_kind(kind: InterruptKind) -\u003e Self {\n        match kind {\n            InterruptKind::Clarification =\u003e Self {\n                default_ttl: Some(Duration::hours(24)),\n                auto_expire: true,\n                require_response: true,\n            },\n            InterruptKind::Confirmation =\u003e Self {\n                default_ttl: Some(Duration::hours(1)),\n                auto_expire: true,\n                require_response: true,\n            },\n            InterruptKind::AgentReview =\u003e Self {\n                default_ttl: Some(Duration::minutes(30)),\n                auto_expire: true,\n                require_response: true,\n            },\n            InterruptKind::Checkpoint =\u003e Self {\n                default_ttl: None,\n                auto_expire: false,\n                require_response: false,\n            },\n            InterruptKind::ResourceExhausted =\u003e Self {\n                default_ttl: Some(Duration::minutes(5)),\n                auto_expire: true,\n                require_response: false,\n            },\n            InterruptKind::Timeout =\u003e Self {\n                default_ttl: Some(Duration::minutes(5)),\n                auto_expire: true,\n                require_response: false,\n            },\n            InterruptKind::SystemError =\u003e Self {\n                default_ttl: Some(Duration::hours(1)),\n                auto_expire: true,\n                require_response: false,\n            },\n        }\n    }\n}\n\n// =============================================================================\n// Kernel Interrupt (extended FlowInterrupt)\n// =============================================================================\n\n/// KernelInterrupt extends FlowInterrupt with kernel-level tracking.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct KernelInterrupt {\n    /// The underlying flow interrupt\n    #[serde(flatten)]\n    pub flow_interrupt: FlowInterrupt,\n\n    // Kernel tracking\n    /// Current status\n    pub status: InterruptStatus,\n    /// Request ID this interrupt belongs to\n    pub request_id: String,\n    /// User ID\n    pub user_id: String,\n    /// Session ID\n    pub session_id: String,\n    /// Envelope ID\n    pub envelope_id: String,\n    /// When the interrupt was resolved\n    pub resolved_at: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    /// Trace ID for distributed tracing\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub trace_id: Option\u003cString\u003e,\n    /// Span ID for distributed tracing\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub span_id: Option\u003cString\u003e,\n}\n\nimpl KernelInterrupt {\n    /// Create a new kernel interrupt.\n    pub fn new(\n        kind: InterruptKind,\n        request_id: String,\n        user_id: String,\n        session_id: String,\n        envelope_id: String,\n        ttl: Option\u003cDuration\u003e,\n    ) -\u003e Self {\n        let now = Utc::now();\n        let expires_at = ttl.map(|d| now + d);\n\n        // Generate interrupt ID\n        let id = format!(\"int_{}\", uuid::Uuid::new_v4().simple().to_string()[..16].to_string());\n\n        Self {\n            flow_interrupt: FlowInterrupt {\n                id,\n                kind,\n                created_at: now,\n                expires_at,\n                question: None,\n                message: None,\n                data: Some(HashMap::new()),\n                response: None,\n            },\n            status: InterruptStatus::Pending,\n            request_id,\n            user_id,\n            session_id,\n            envelope_id,\n            resolved_at: None,\n            trace_id: None,\n            span_id: None,\n        }\n    }\n\n    /// Check if the interrupt has expired.\n    pub fn is_expired(\u0026self) -\u003e bool {\n        if let Some(expires_at) = self.flow_interrupt.expires_at {\n            Utc::now() \u003e expires_at\n        } else {\n            false\n        }\n    }\n\n    /// Check if the interrupt is pending.\n    pub fn is_pending(\u0026self) -\u003e bool {\n        self.status == InterruptStatus::Pending\n    }\n}\n\n// =============================================================================\n// Interrupt Service\n// =============================================================================\n\n/// InterruptService manages interrupt lifecycle.\n///\n/// Single-actor implementation for creating, querying, and resolving interrupts.\n#[derive(Debug)]\npub struct InterruptService {\n    /// Configuration per interrupt kind\n    configs: HashMap\u003cInterruptKind, InterruptConfig\u003e,\n    /// In-memory store keyed by interrupt ID\n    store: HashMap\u003cString, KernelInterrupt\u003e,\n    /// Index by request ID for fast lookup\n    by_request: HashMap\u003cString, Vec\u003cString\u003e\u003e,\n    /// Index by session ID\n    by_session: HashMap\u003cString, Vec\u003cString\u003e\u003e,\n}\n\nimpl InterruptService {\n    /// Create a new interrupt service with default configurations.\n    pub fn new() -\u003e Self {\n        let mut configs = HashMap::new();\n\n        // Initialize default configs for all interrupt kinds\n        for kind in \u0026[\n            InterruptKind::Clarification,\n            InterruptKind::Confirmation,\n            InterruptKind::AgentReview,\n            InterruptKind::Checkpoint,\n            InterruptKind::ResourceExhausted,\n            InterruptKind::Timeout,\n            InterruptKind::SystemError,\n        ] {\n            configs.insert(*kind, InterruptConfig::default_for_kind(*kind));\n        }\n\n        Self {\n            configs,\n            store: HashMap::new(),\n            by_request: HashMap::new(),\n            by_session: HashMap::new(),\n        }\n    }\n\n    /// Create with custom configurations.\n    pub fn with_configs(custom_configs: HashMap\u003cInterruptKind, InterruptConfig\u003e) -\u003e Self {\n        let mut service = Self::new();\n        // Override defaults with custom configs\n        for (kind, config) in custom_configs {\n            service.configs.insert(kind, config);\n        }\n        service\n    }\n\n    /// Get configuration for an interrupt kind.\n    pub fn get_config(\u0026self, kind: InterruptKind) -\u003e InterruptConfig {\n        self.configs\n            .get(\u0026kind)\n            .cloned()\n            .unwrap_or_else(|| InterruptConfig {\n                default_ttl: Some(Duration::hours(1)),\n                auto_expire: true,\n                require_response: true,\n            })\n    }\n\n    // =============================================================================\n    // Create Interrupts\n    // =============================================================================\n\n    /// Create a new interrupt.\n    pub fn create_interrupt(\n        \u0026mut self,\n        kind: InterruptKind,\n        request_id: String,\n        user_id: String,\n        session_id: String,\n        envelope_id: String,\n        question: Option\u003cString\u003e,\n        message: Option\u003cString\u003e,\n        data: Option\u003cHashMap\u003cString, serde_json::Value\u003e\u003e,\n        trace_id: Option\u003cString\u003e,\n        span_id: Option\u003cString\u003e,\n    ) -\u003e KernelInterrupt {\n        let config = self.get_config(kind);\n        let mut interrupt = KernelInterrupt::new(\n            kind,\n            request_id.clone(),\n            user_id,\n            session_id.clone(),\n            envelope_id,\n            config.default_ttl,\n        );\n\n        // Apply options\n        if let Some(q) = question {\n            interrupt.flow_interrupt.question = Some(q);\n        }\n        if let Some(m) = message {\n            interrupt.flow_interrupt.message = Some(m);\n        }\n        if let Some(d) = data {\n            interrupt.flow_interrupt.data = Some(d);\n        }\n        interrupt.trace_id = trace_id;\n        interrupt.span_id = span_id;\n\n        // Store interrupt\n        let interrupt_id = interrupt.flow_interrupt.id.clone();\n        self.store.insert(interrupt_id.clone(), interrupt.clone());\n\n        // Index by request\n        self.by_request\n            .entry(request_id)\n            .or_insert_with(Vec::new)\n            .push(interrupt_id.clone());\n\n        // Index by session\n        self.by_session\n            .entry(session_id)\n            .or_insert_with(Vec::new)\n            .push(interrupt_id);\n\n        interrupt\n    }\n\n    /// Convenience method to create a clarification interrupt.\n    pub fn create_clarification(\n        \u0026mut self,\n        request_id: String,\n        user_id: String,\n        session_id: String,\n        envelope_id: String,\n        question: String,\n        context: Option\u003cHashMap\u003cString, serde_json::Value\u003e\u003e,\n    ) -\u003e KernelInterrupt {\n        self.create_interrupt(\n            InterruptKind::Clarification,\n            request_id,\n            user_id,\n            session_id,\n            envelope_id,\n            Some(question),\n            None,\n            context,\n            None,\n            None,\n        )\n    }\n\n    /// Convenience method to create a confirmation interrupt.\n    pub fn create_confirmation(\n        \u0026mut self,\n        request_id: String,\n        user_id: String,\n        session_id: String,\n        envelope_id: String,\n        message: String,\n        action_data: Option\u003cHashMap\u003cString, serde_json::Value\u003e\u003e,\n    ) -\u003e KernelInterrupt {\n        self.create_interrupt(\n            InterruptKind::Confirmation,\n            request_id,\n            user_id,\n            session_id,\n            envelope_id,\n            None,\n            Some(message),\n            action_data,\n            None,\n            None,\n        )\n    }\n\n    /// Convenience method to create a resource exhausted interrupt.\n    pub fn create_resource_exhausted(\n        \u0026mut self,\n        request_id: String,\n        user_id: String,\n        session_id: String,\n        envelope_id: String,\n        resource_type: String,\n        retry_after_seconds: f64,\n    ) -\u003e KernelInterrupt {\n        let mut data = HashMap::new();\n        data.insert(\n            \"resource_type\".to_string(),\n            serde_json::Value::String(resource_type.clone()),\n        );\n        data.insert(\n            \"retry_after_seconds\".to_string(),\n            serde_json::json!(retry_after_seconds),\n        );\n\n        self.create_interrupt(\n            InterruptKind::ResourceExhausted,\n            request_id,\n            user_id,\n            session_id,\n            envelope_id,\n            None,\n            Some(format!(\"Resource exhausted: {}\", resource_type)),\n            Some(data),\n            None,\n            None,\n        )\n    }\n\n    // =============================================================================\n    // Query Interrupts\n    // =============================================================================\n\n    /// Get an interrupt by ID.\n    pub fn get_interrupt(\u0026self, interrupt_id: \u0026str) -\u003e Option\u003c\u0026KernelInterrupt\u003e {\n        self.store.get(interrupt_id)\n    }\n\n    /// Get the most recent pending interrupt for a request.\n    pub fn get_pending_for_request(\u0026self, request_id: \u0026str) -\u003e Option\u003c\u0026KernelInterrupt\u003e {\n        let interrupt_ids = self.by_request.get(request_id)?;\n\n        // Return most recent pending (iterate backwards)\n        for interrupt_id in interrupt_ids.iter().rev() {\n            if let Some(interrupt) = self.store.get(interrupt_id) {\n                if interrupt.is_pending() \u0026\u0026 !interrupt.is_expired() {\n                    return Some(interrupt);\n                }\n            }\n        }\n        None\n    }\n\n    /// Get all pending interrupts for a session, optionally filtered by kind.\n    pub fn get_pending_for_session(\n        \u0026self,\n        session_id: \u0026str,\n        kinds: Option\u003c\u0026[InterruptKind]\u003e,\n    ) -\u003e Vec\u003c\u0026KernelInterrupt\u003e {\n        let interrupt_ids = match self.by_session.get(session_id) {\n            Some(ids) =\u003e ids,\n            None =\u003e return Vec::new(),\n        };\n\n        let kind_set: Option\u003cstd::collections::HashSet\u003cInterruptKind\u003e\u003e =\n            kinds.map(|ks| ks.iter().copied().collect());\n\n        interrupt_ids\n            .iter()\n            .filter_map(|id| self.store.get(id))\n            .filter(|interrupt| interrupt.is_pending() \u0026\u0026 !interrupt.is_expired())\n            .filter(|interrupt| {\n                kind_set\n                    .as_ref()\n                    .map(|set| set.contains(\u0026interrupt.flow_interrupt.kind))\n                    .unwrap_or(true)\n            })\n            .collect()\n    }\n\n    // =============================================================================\n    // Resolve Interrupts\n    // =============================================================================\n\n    /// Resolve an interrupt with a response.\n    /// Returns true if successful, false if not found or invalid.\n    pub fn resolve(\n        \u0026mut self,\n        interrupt_id: \u0026str,\n        response: InterruptResponse,\n        user_id: Option\u003c\u0026str\u003e,\n    ) -\u003e bool {\n        let interrupt = match self.store.get_mut(interrupt_id) {\n            Some(i) =\u003e i,\n            None =\u003e return false,\n        };\n\n        if interrupt.status != InterruptStatus::Pending {\n            return false;\n        }\n\n        // Validate user if provided\n        if let Some(uid) = user_id {\n            if interrupt.user_id != uid {\n                return false;\n            }\n        }\n\n        // Update interrupt\n        let now = Utc::now();\n        let mut updated_response = response;\n        updated_response.received_at = now;\n        interrupt.flow_interrupt.response = Some(updated_response);\n        interrupt.status = InterruptStatus::Resolved;\n        interrupt.resolved_at = Some(now);\n\n        true\n    }\n\n    /// Cancel an interrupt.\n    pub fn cancel(\u0026mut self, interrupt_id: \u0026str, reason: String) -\u003e bool {\n        let interrupt = match self.store.get_mut(interrupt_id) {\n            Some(i) =\u003e i,\n            None =\u003e return false,\n        };\n\n        if interrupt.status != InterruptStatus::Pending {\n            return false;\n        }\n\n        interrupt.status = InterruptStatus::Cancelled;\n\n        // Ensure data exists\n        if interrupt.flow_interrupt.data.is_none() {\n            interrupt.flow_interrupt.data = Some(HashMap::new());\n        }\n        if let Some(data) = \u0026mut interrupt.flow_interrupt.data {\n            data.insert(\"cancel_reason\".to_string(), serde_json::json!(reason));\n        }\n\n        true\n    }\n\n    /// Expire all pending interrupts that have passed their expiry time.\n    /// Returns the number of interrupts expired.\n    pub fn expire_pending(\u0026mut self) -\u003e usize {\n        let mut count = 0;\n\n        for interrupt in self.store.values_mut() {\n            if interrupt.is_pending() \u0026\u0026 interrupt.is_expired() {\n                interrupt.status = InterruptStatus::Expired;\n                count += 1;\n            }\n        }\n\n        count\n    }\n\n    // =============================================================================\n    // Cleanup\n    // =============================================================================\n\n    /// Remove resolved/expired/cancelled interrupts older than the given duration.\n    /// Returns the number of interrupts cleaned up.\n    pub fn cleanup_resolved(\u0026mut self, older_than: Duration) -\u003e usize {\n        let cutoff = Utc::now() - older_than;\n        let mut to_delete = Vec::new();\n\n        for (id, interrupt) in \u0026self.store {\n            if interrupt.status != InterruptStatus::Pending\n                \u0026\u0026 interrupt.flow_interrupt.created_at \u003c cutoff\n            {\n                to_delete.push(id.clone());\n            }\n        }\n\n        let count = to_delete.len();\n        for id in to_delete {\n            if let Some(interrupt) = self.store.remove(\u0026id) {\n                // Remove from indices\n                Self::remove_from_index(\u0026mut self.by_request, \u0026interrupt.request_id, \u0026id);\n                Self::remove_from_index(\u0026mut self.by_session, \u0026interrupt.session_id, \u0026id);\n            }\n        }\n\n        count\n    }\n\n    /// Remove an interrupt from an index slice.\n    fn remove_from_index(index: \u0026mut HashMap\u003cString, Vec\u003cString\u003e\u003e, key: \u0026str, interrupt_id: \u0026str) {\n        if let Some(interrupts) = index.get_mut(key) {\n            interrupts.retain(|id| id != interrupt_id);\n            if interrupts.is_empty() {\n                index.remove(key);\n            }\n        }\n    }\n\n    // =============================================================================\n    // Statistics\n    // =============================================================================\n\n    /// Get statistics about interrupts.\n    pub fn get_stats(\u0026self) -\u003e HashMap\u003cString, usize\u003e {\n        let mut stats = HashMap::new();\n        stats.insert(\"total\".to_string(), self.store.len());\n        stats.insert(\"pending\".to_string(), 0);\n        stats.insert(\"resolved\".to_string(), 0);\n        stats.insert(\"expired\".to_string(), 0);\n        stats.insert(\"cancelled\".to_string(), 0);\n\n        for interrupt in self.store.values() {\n            let key = match interrupt.status {\n                InterruptStatus::Pending =\u003e \"pending\",\n                InterruptStatus::Resolved =\u003e \"resolved\",\n                InterruptStatus::Expired =\u003e \"expired\",\n                InterruptStatus::Cancelled =\u003e \"cancelled\",\n            };\n            *stats.get_mut(key).unwrap() += 1;\n        }\n\n        stats\n    }\n\n    /// Get the number of pending interrupts.\n    pub fn get_pending_count(\u0026self) -\u003e usize {\n        self.store\n            .values()\n            .filter(|i| i.is_pending())\n            .count()\n    }\n}\n\nimpl Default for InterruptService {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","jeeves-core","src","kernel","lifecycle.rs"],"content":"//! Process lifecycle management.\n//!\n//! Implements Unix-like process state machine with priority scheduling:\n//! NEW → READY → RUNNING → {WAITING|BLOCKED|TERMINATED} → ZOMBIE\n\nuse chrono::{DateTime, Utc};\nuse std::cmp::Ordering;\nuse std::collections::{BinaryHeap, HashMap};\n\nuse crate::types::{Error, Result};\n\npub use super::types::{ProcessControlBlock, ProcessState, ResourceQuota, SchedulingPriority};\n\n/// Priority queue item (wraps for min-heap behavior).\n#[derive(Debug, Clone, PartialEq, Eq)]\nstruct PriorityItem {\n    pid: String,\n    priority: i32,      // Lower = higher priority\n    created_at: DateTime\u003cUtc\u003e, // FIFO within same priority\n}\n\nimpl Ord for PriorityItem {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n        // BinaryHeap is max-heap, so reverse priority\n        other\n            .priority\n            .cmp(\u0026self.priority)\n            // Then FIFO for same priority\n            .then_with(|| self.created_at.cmp(\u0026other.created_at))\n    }\n}\n\nimpl PartialOrd for PriorityItem {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\n/// Lifecycle manager - kernel's process scheduler.\n///\n/// Manages process lifecycles with priority-based ready queue.\n/// NOT a separate actor - owned by Kernel and called via \u0026mut self.\n#[derive(Debug)]\npub struct LifecycleManager {\n    default_quota: ResourceQuota,\n    processes: HashMap\u003cString, ProcessControlBlock\u003e,\n    ready_queue: BinaryHeap\u003cPriorityItem\u003e,\n}\n\nimpl LifecycleManager {\n    pub fn new(default_quota: Option\u003cResourceQuota\u003e) -\u003e Self {\n        Self {\n            default_quota: default_quota.unwrap_or_default(),\n            processes: HashMap::new(),\n            ready_queue: BinaryHeap::new(),\n        }\n    }\n\n    /// Submit creates a new process in NEW state.\n    pub fn submit(\n        \u0026mut self,\n        pid: String,\n        request_id: String,\n        user_id: String,\n        session_id: String,\n        priority: SchedulingPriority,\n        quota: Option\u003cResourceQuota\u003e,\n    ) -\u003e Result\u003cProcessControlBlock\u003e {\n        // Check for duplicate\n        if let Some(existing) = self.processes.get(\u0026pid) {\n            return Ok(existing.clone());\n        }\n\n        // Create PCB\n        let mut pcb = ProcessControlBlock::new(pid.clone(), request_id, user_id, session_id);\n        pcb.priority = priority;\n        pcb.quota = quota.unwrap_or_else(|| self.default_quota.clone());\n\n        self.processes.insert(pid, pcb.clone());\n        Ok(pcb)\n    }\n\n    /// Schedule transitions process from NEW to READY and adds to queue.\n    pub fn schedule(\u0026mut self, pid: \u0026str) -\u003e Result\u003c()\u003e {\n        let pcb = self\n            .processes\n            .get_mut(pid)\n            .ok_or_else(|| Error::not_found(format!(\"unknown pid: {}\", pid)))?;\n\n        if pcb.state != ProcessState::New {\n            return Err(Error::state_transition(format!(\n                \"cannot schedule pid {}: state is {:?}, expected New\",\n                pid, pcb.state\n            )));\n        }\n\n        // Transition to READY\n        pcb.state = ProcessState::Ready;\n\n        // Add to ready queue\n        self.ready_queue.push(PriorityItem {\n            pid: pid.to_string(),\n            priority: pcb.priority.to_heap_value(),\n            created_at: pcb.created_at,\n        });\n\n        Ok(())\n    }\n\n    /// Get next runnable process (highest priority from ready queue).\n    pub fn get_next_runnable(\u0026mut self) -\u003e Option\u003cProcessControlBlock\u003e {\n        while let Some(item) = self.ready_queue.pop() {\n            if let Some(pcb) = self.processes.get(\u0026item.pid) {\n                if pcb.state == ProcessState::Ready {\n                    return Some(pcb.clone());\n                }\n            }\n        }\n        None\n    }\n\n    /// Transition process to RUNNING state.\n    pub fn start(\u0026mut self, pid: \u0026str) -\u003e Result\u003c()\u003e {\n        let pcb = self\n            .processes\n            .get_mut(pid)\n            .ok_or_else(|| Error::not_found(format!(\"unknown pid: {}\", pid)))?;\n\n        if pcb.state != ProcessState::Ready {\n            return Err(Error::state_transition(format!(\n                \"cannot start pid {}: state is {:?}, expected Ready\",\n                pid, pcb.state\n            )));\n        }\n\n        pcb.start();\n        Ok(())\n    }\n\n    /// Transition process to WAITING state (e.g., awaiting clarification).\n    pub fn wait(\u0026mut self, pid: \u0026str, interrupt_kind: crate::envelope::InterruptKind) -\u003e Result\u003c()\u003e {\n        let pcb = self\n            .processes\n            .get_mut(pid)\n            .ok_or_else(|| Error::not_found(format!(\"unknown pid: {}\", pid)))?;\n\n        if pcb.state != ProcessState::Running {\n            return Err(Error::state_transition(format!(\n                \"cannot wait pid {}: state is {:?}, expected Running\",\n                pid, pcb.state\n            )));\n        }\n\n        pcb.wait(interrupt_kind);\n        Ok(())\n    }\n\n    /// Transition process to BLOCKED state (e.g., resource exhausted).\n    pub fn block(\u0026mut self, pid: \u0026str, reason: String) -\u003e Result\u003c()\u003e {\n        let pcb = self\n            .processes\n            .get_mut(pid)\n            .ok_or_else(|| Error::not_found(format!(\"unknown pid: {}\", pid)))?;\n\n        if pcb.state != ProcessState::Running {\n            return Err(Error::state_transition(format!(\n                \"cannot block pid {}: state is {:?}, expected Running\",\n                pid, pcb.state\n            )));\n        }\n\n        pcb.block(reason);\n        Ok(())\n    }\n\n    /// Resume process from WAITING/BLOCKED to READY.\n    pub fn resume(\u0026mut self, pid: \u0026str) -\u003e Result\u003c()\u003e {\n        let pcb = self\n            .processes\n            .get_mut(pid)\n            .ok_or_else(|| Error::not_found(format!(\"unknown pid: {}\", pid)))?;\n\n        if !matches!(pcb.state, ProcessState::Waiting | ProcessState::Blocked) {\n            return Err(Error::state_transition(format!(\n                \"cannot resume pid {}: state is {:?}, expected Waiting or Blocked\",\n                pid, pcb.state\n            )));\n        }\n\n        pcb.resume();\n\n        // Re-add to ready queue\n        self.ready_queue.push(PriorityItem {\n            pid: pid.to_string(),\n            priority: pcb.priority.to_heap_value(),\n            created_at: pcb.created_at,\n        });\n\n        Ok(())\n    }\n\n    /// Terminate process.\n    pub fn terminate(\u0026mut self, pid: \u0026str) -\u003e Result\u003c()\u003e {\n        let pcb = self\n            .processes\n            .get_mut(pid)\n            .ok_or_else(|| Error::not_found(format!(\"unknown pid: {}\", pid)))?;\n\n        if pcb.state.is_terminal() {\n            return Ok(()); // Already terminated\n        }\n\n        pcb.complete();\n        Ok(())\n    }\n\n    /// Cleanup terminated process (transition to ZOMBIE).\n    pub fn cleanup(\u0026mut self, pid: \u0026str) -\u003e Result\u003c()\u003e {\n        let pcb = self\n            .processes\n            .get_mut(pid)\n            .ok_or_else(|| Error::not_found(format!(\"unknown pid: {}\", pid)))?;\n\n        if pcb.state != ProcessState::Terminated {\n            return Err(Error::state_transition(format!(\n                \"cannot cleanup pid {}: state is {:?}, expected Terminated\",\n                pid, pcb.state\n            )));\n        }\n\n        pcb.state = ProcessState::Zombie;\n        Ok(())\n    }\n\n    /// Remove process completely (zombie collection).\n    pub fn remove(\u0026mut self, pid: \u0026str) -\u003e Result\u003cProcessControlBlock\u003e {\n        self.processes\n            .remove(pid)\n            .ok_or_else(|| Error::not_found(format!(\"unknown pid: {}\", pid)))\n    }\n\n    /// Get process by PID.\n    pub fn get(\u0026self, pid: \u0026str) -\u003e Option\u003c\u0026ProcessControlBlock\u003e {\n        self.processes.get(pid)\n    }\n\n    /// Get mutable process by PID.\n    pub fn get_mut(\u0026mut self, pid: \u0026str) -\u003e Option\u003c\u0026mut ProcessControlBlock\u003e {\n        self.processes.get_mut(pid)\n    }\n\n    /// List all processes.\n    pub fn list(\u0026self) -\u003e Vec\u003cProcessControlBlock\u003e {\n        self.processes.values().cloned().collect()\n    }\n\n    /// List processes by state.\n    pub fn list_by_state(\u0026self, state: ProcessState) -\u003e Vec\u003cProcessControlBlock\u003e {\n        self.processes\n            .values()\n            .filter(|pcb| pcb.state == state)\n            .cloned()\n            .collect()\n    }\n\n    /// Count processes.\n    pub fn count(\u0026self) -\u003e usize {\n        self.processes.len()\n    }\n\n    /// Count processes by state.\n    pub fn count_by_state(\u0026self, state: ProcessState) -\u003e usize {\n        self.processes\n            .values()\n            .filter(|pcb| pcb.state == state)\n            .count()\n    }\n}\n\nimpl Default for LifecycleManager {\n    fn default() -\u003e Self {\n        Self::new(None)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_state_transitions() {\n        let mut lm = LifecycleManager::default();\n\n        // Submit process\n        let pcb = lm\n            .submit(\n                \"pid1\".to_string(),\n                \"req1\".to_string(),\n                \"user1\".to_string(),\n                \"sess1\".to_string(),\n                SchedulingPriority::Normal,\n                None,\n            )\n            .unwrap();\n        assert_eq!(pcb.state, ProcessState::New);\n\n        // Schedule to READY\n        lm.schedule(\"pid1\").unwrap();\n        assert_eq!(lm.get(\"pid1\").unwrap().state, ProcessState::Ready);\n\n        // Start to RUNNING\n        lm.start(\"pid1\").unwrap();\n        assert_eq!(lm.get(\"pid1\").unwrap().state, ProcessState::Running);\n\n        // Terminate\n        lm.terminate(\"pid1\").unwrap();\n        assert_eq!(lm.get(\"pid1\").unwrap().state, ProcessState::Terminated);\n\n        // Cleanup to ZOMBIE\n        lm.cleanup(\"pid1\").unwrap();\n        assert_eq!(lm.get(\"pid1\").unwrap().state, ProcessState::Zombie);\n    }\n\n    #[test]\n    fn test_priority_queue() {\n        let mut lm = LifecycleManager::default();\n\n        // Submit 3 processes with different priorities\n        lm.submit(\n            \"low\".to_string(),\n            \"r1\".to_string(),\n            \"u1\".to_string(),\n            \"s1\".to_string(),\n            SchedulingPriority::Low,\n            None,\n        )\n        .unwrap();\n        lm.submit(\n            \"high\".to_string(),\n            \"r2\".to_string(),\n            \"u2\".to_string(),\n            \"s2\".to_string(),\n            SchedulingPriority::High,\n            None,\n        )\n        .unwrap();\n        lm.submit(\n            \"normal\".to_string(),\n            \"r3\".to_string(),\n            \"u3\".to_string(),\n            \"s3\".to_string(),\n            SchedulingPriority::Normal,\n            None,\n        )\n        .unwrap();\n\n        // Schedule all\n        lm.schedule(\"low\").unwrap();\n        lm.schedule(\"high\").unwrap();\n        lm.schedule(\"normal\").unwrap();\n\n        // Should dequeue in priority order: high, normal, low\n        let next = lm.get_next_runnable().unwrap();\n        assert_eq!(next.pid, \"high\");\n\n        let next = lm.get_next_runnable().unwrap();\n        assert_eq!(next.pid, \"normal\");\n\n        let next = lm.get_next_runnable().unwrap();\n        assert_eq!(next.pid, \"low\");\n    }\n\n    #[test]\n    fn test_state_validation() {\n        assert!(ProcessState::New.can_transition_to(ProcessState::Ready));\n        assert!(ProcessState::Ready.can_transition_to(ProcessState::Running));\n        assert!(ProcessState::Running.can_transition_to(ProcessState::Waiting));\n        assert!(ProcessState::Running.can_transition_to(ProcessState::Blocked));\n        assert!(ProcessState::Running.can_transition_to(ProcessState::Terminated));\n        assert!(ProcessState::Waiting.can_transition_to(ProcessState::Ready));\n        assert!(ProcessState::Blocked.can_transition_to(ProcessState::Ready));\n        assert!(ProcessState::Terminated.can_transition_to(ProcessState::Zombie));\n\n        // Invalid transitions\n        assert!(!ProcessState::New.can_transition_to(ProcessState::Running));\n        assert!(!ProcessState::Ready.can_transition_to(ProcessState::Waiting));\n        assert!(!ProcessState::Zombie.can_transition_to(ProcessState::Ready));\n    }\n\n    #[test]\n    fn test_submit_duplicate_pid_returns_existing() {\n        let mut lm = LifecycleManager::default();\n\n        // Submit process\n        let pcb1 = lm\n            .submit(\n                \"pid1\".to_string(),\n                \"req1\".to_string(),\n                \"user1\".to_string(),\n                \"sess1\".to_string(),\n                SchedulingPriority::Normal,\n                None,\n            )\n            .unwrap();\n\n        // Submit again with same PID\n        let pcb2 = lm\n            .submit(\n                \"pid1\".to_string(),\n                \"req2\".to_string(),\n                \"user2\".to_string(),\n                \"sess2\".to_string(),\n                SchedulingPriority::High,\n                None,\n            )\n            .unwrap();\n\n        // Should return existing process\n        assert_eq!(pcb1.pid, pcb2.pid);\n        assert_eq!(pcb2.request_id, \"req1\"); // Original, not new\n    }\n\n    #[test]\n    fn test_transition_invalid_state_fails() {\n        let mut lm = LifecycleManager::default();\n\n        lm.submit(\n            \"pid1\".to_string(),\n            \"req1\".to_string(),\n            \"user1\".to_string(),\n            \"sess1\".to_string(),\n            SchedulingPriority::Normal,\n            None,\n        )\n        .unwrap();\n\n        // Try to start without scheduling (NEW → RUNNING invalid)\n        assert!(lm.start(\"pid1\").is_err());\n\n        // Schedule to READY\n        lm.schedule(\"pid1\").unwrap();\n\n        // Try to wait from READY (should be RUNNING)\n        assert!(lm.wait(\"pid1\", crate::envelope::InterruptKind::Clarification).is_err());\n    }\n\n    #[test]\n    fn test_get_next_runnable_empty_queue() {\n        let lm = LifecycleManager::default();\n\n        // Empty queue should return None\n        let mut lm = lm;\n        assert!(lm.get_next_runnable().is_none());\n    }\n\n    #[test]\n    fn test_count_by_state() {\n        let mut lm = LifecycleManager::default();\n\n        // Submit 3 processes\n        lm.submit(\n            \"pid1\".to_string(),\n            \"req1\".to_string(),\n            \"user1\".to_string(),\n            \"sess1\".to_string(),\n            SchedulingPriority::Normal,\n            None,\n        )\n        .unwrap();\n        lm.submit(\n            \"pid2\".to_string(),\n            \"req2\".to_string(),\n            \"user2\".to_string(),\n            \"sess2\".to_string(),\n            SchedulingPriority::Normal,\n            None,\n        )\n        .unwrap();\n        lm.submit(\n            \"pid3\".to_string(),\n            \"req3\".to_string(),\n            \"user3\".to_string(),\n            \"sess3\".to_string(),\n            SchedulingPriority::Normal,\n            None,\n        )\n        .unwrap();\n\n        // All in NEW state\n        assert_eq!(lm.count_by_state(ProcessState::New), 3);\n        assert_eq!(lm.count_by_state(ProcessState::Ready), 0);\n\n        // Schedule 2 of them\n        lm.schedule(\"pid1\").unwrap();\n        lm.schedule(\"pid2\").unwrap();\n\n        assert_eq!(lm.count_by_state(ProcessState::New), 1);\n        assert_eq!(lm.count_by_state(ProcessState::Ready), 2);\n    }\n\n    #[test]\n    fn test_wait_and_resume() {\n        let mut lm = LifecycleManager::default();\n\n        lm.submit(\n            \"pid1\".to_string(),\n            \"req1\".to_string(),\n            \"user1\".to_string(),\n            \"sess1\".to_string(),\n            SchedulingPriority::Normal,\n            None,\n        )\n        .unwrap();\n        lm.schedule(\"pid1\").unwrap();\n        lm.start(\"pid1\").unwrap();\n\n        // RUNNING → WAITING\n        lm.wait(\"pid1\", crate::envelope::InterruptKind::Clarification).unwrap();\n        assert_eq!(lm.get(\"pid1\").unwrap().state, ProcessState::Waiting);\n\n        // WAITING → READY\n        lm.resume(\"pid1\").unwrap();\n        assert_eq!(lm.get(\"pid1\").unwrap().state, ProcessState::Ready);\n\n        // Should be back in ready queue\n        let next = lm.get_next_runnable().unwrap();\n        assert_eq!(next.pid, \"pid1\");\n    }\n\n    #[test]\n    fn test_block_and_resume() {\n        let mut lm = LifecycleManager::default();\n\n        lm.submit(\n            \"pid1\".to_string(),\n            \"req1\".to_string(),\n            \"user1\".to_string(),\n            \"sess1\".to_string(),\n            SchedulingPriority::Normal,\n            None,\n        )\n        .unwrap();\n        lm.schedule(\"pid1\").unwrap();\n        lm.start(\"pid1\").unwrap();\n\n        // RUNNING → BLOCKED\n        lm.block(\"pid1\", \"quota exceeded\".to_string()).unwrap();\n        assert_eq!(lm.get(\"pid1\").unwrap().state, ProcessState::Blocked);\n\n        // BLOCKED → READY\n        lm.resume(\"pid1\").unwrap();\n        assert_eq!(lm.get(\"pid1\").unwrap().state, ProcessState::Ready);\n\n        // Should be back in ready queue\n        let next = lm.get_next_runnable().unwrap();\n        assert_eq!(next.pid, \"pid1\");\n    }\n\n    #[test]\n    fn test_process_not_found_errors() {\n        let mut lm = LifecycleManager::default();\n\n        // Operations on non-existent PID should fail\n        assert!(lm.schedule(\"nonexistent\").is_err());\n        assert!(lm.start(\"nonexistent\").is_err());\n        assert!(lm.wait(\"nonexistent\", crate::envelope::InterruptKind::Clarification).is_err());\n        assert!(lm.block(\"nonexistent\", \"reason\".to_string()).is_err());\n        assert!(lm.resume(\"nonexistent\").is_err());\n        assert!(lm.terminate(\"nonexistent\").is_err());\n        assert!(lm.cleanup(\"nonexistent\").is_err());\n        assert!(lm.remove(\"nonexistent\").is_err());\n\n        // Get returns None\n        assert!(lm.get(\"nonexistent\").is_none());\n    }\n\n    #[test]\n    fn test_cleanup_and_remove() {\n        let mut lm = LifecycleManager::default();\n\n        lm.submit(\n            \"pid1\".to_string(),\n            \"req1\".to_string(),\n            \"user1\".to_string(),\n            \"sess1\".to_string(),\n            SchedulingPriority::Normal,\n            None,\n        )\n        .unwrap();\n        lm.schedule(\"pid1\").unwrap();\n        lm.start(\"pid1\").unwrap();\n        lm.terminate(\"pid1\").unwrap();\n\n        assert_eq!(lm.get(\"pid1\").unwrap().state, ProcessState::Terminated);\n        assert_eq!(lm.count(), 1);\n\n        // Cleanup to ZOMBIE\n        lm.cleanup(\"pid1\").unwrap();\n        assert_eq!(lm.get(\"pid1\").unwrap().state, ProcessState::Zombie);\n        assert_eq!(lm.count(), 1); // Still exists\n\n        // Remove completely\n        let removed = lm.remove(\"pid1\").unwrap();\n        assert_eq!(removed.pid, \"pid1\");\n        assert_eq!(lm.count(), 0);\n        assert!(lm.get(\"pid1\").is_none());\n    }\n\n    #[test]\n    fn test_schedule_wrong_state_fails() {\n        let mut lm = LifecycleManager::default();\n\n        lm.submit(\n            \"pid1\".to_string(),\n            \"req1\".to_string(),\n            \"user1\".to_string(),\n            \"sess1\".to_string(),\n            SchedulingPriority::Normal,\n            None,\n        )\n        .unwrap();\n        lm.schedule(\"pid1\").unwrap();\n\n        // Try to schedule again (already READY)\n        assert!(lm.schedule(\"pid1\").is_err());\n    }\n\n    #[test]\n    fn test_list_by_state() {\n        let mut lm = LifecycleManager::default();\n\n        lm.submit(\n            \"pid1\".to_string(),\n            \"req1\".to_string(),\n            \"user1\".to_string(),\n            \"sess1\".to_string(),\n            SchedulingPriority::Normal,\n            None,\n        )\n        .unwrap();\n        lm.submit(\n            \"pid2\".to_string(),\n            \"req2\".to_string(),\n            \"user2\".to_string(),\n            \"sess2\".to_string(),\n            SchedulingPriority::Normal,\n            None,\n        )\n        .unwrap();\n        lm.submit(\n            \"pid3\".to_string(),\n            \"req3\".to_string(),\n            \"user3\".to_string(),\n            \"sess3\".to_string(),\n            SchedulingPriority::Normal,\n            None,\n        )\n        .unwrap();\n\n        // All in NEW\n        let new_processes = lm.list_by_state(ProcessState::New);\n        assert_eq!(new_processes.len(), 3);\n\n        // Schedule 2\n        lm.schedule(\"pid1\").unwrap();\n        lm.schedule(\"pid2\").unwrap();\n\n        let ready_processes = lm.list_by_state(ProcessState::Ready);\n        assert_eq!(ready_processes.len(), 2);\n\n        let new_processes = lm.list_by_state(ProcessState::New);\n        assert_eq!(new_processes.len(), 1);\n    }\n\n    #[test]\n    fn test_remove_process() {\n        let mut lm = LifecycleManager::default();\n\n        lm.submit(\n            \"pid1\".to_string(),\n            \"req1\".to_string(),\n            \"user1\".to_string(),\n            \"sess1\".to_string(),\n            SchedulingPriority::Normal,\n            None,\n        )\n        .unwrap();\n\n        assert_eq!(lm.count(), 1);\n\n        // Remove returns the process\n        let removed = lm.remove(\"pid1\").unwrap();\n        assert_eq!(removed.pid, \"pid1\");\n\n        // Process is gone\n        assert_eq!(lm.count(), 0);\n        assert!(lm.get(\"pid1\").is_none());\n    }\n\n    #[test]\n    fn test_terminate_idempotent() {\n        let mut lm = LifecycleManager::default();\n\n        lm.submit(\n            \"pid1\".to_string(),\n            \"req1\".to_string(),\n            \"user1\".to_string(),\n            \"sess1\".to_string(),\n            SchedulingPriority::Normal,\n            None,\n        )\n        .unwrap();\n        lm.schedule(\"pid1\").unwrap();\n        lm.start(\"pid1\").unwrap();\n\n        // Terminate\n        lm.terminate(\"pid1\").unwrap();\n        assert_eq!(lm.get(\"pid1\").unwrap().state, ProcessState::Terminated);\n\n        // Terminate again should succeed (idempotent)\n        assert!(lm.terminate(\"pid1\").is_ok());\n        assert_eq!(lm.get(\"pid1\").unwrap().state, ProcessState::Terminated);\n    }\n}\n\n","traces":[{"line":29,"address":[5863626,5863728,5863738,5863786],"length":1,"stats":{"Line":1}},{"line":34,"address":[5920432],"length":1,"stats":{"Line":0}},{"line":60,"address":[5918144,5918946],"length":1,"stats":{"Line":1}},{"line":70,"address":[5918182,5918244],"length":1,"stats":{"Line":2}},{"line":71,"address":[5918257],"length":1,"stats":{"Line":1}},{"line":75,"address":[5918375],"length":1,"stats":{"Line":1}},{"line":76,"address":[5918514],"length":1,"stats":{"Line":1}},{"line":77,"address":[5862880,5862913],"length":1,"stats":{"Line":1}},{"line":79,"address":[5918845,5918583],"length":1,"stats":{"Line":1}},{"line":80,"address":[5918683],"length":1,"stats":{"Line":1}},{"line":84,"address":[5919408],"length":1,"stats":{"Line":1}},{"line":85,"address":[5919573,5919450],"length":1,"stats":{"Line":2}},{"line":88,"address":[5863171,5863152,5863313,5863274,5863220],"length":1,"stats":{"Line":5}},{"line":90,"address":[5919591],"length":1,"stats":{"Line":1}},{"line":91,"address":[5919610,5919848,5919902],"length":1,"stats":{"Line":2}},{"line":98,"address":[5919704],"length":1,"stats":{"Line":1}},{"line":101,"address":[5919760],"length":1,"stats":{"Line":1}},{"line":102,"address":[5919717],"length":1,"stats":{"Line":1}},{"line":103,"address":[5919729],"length":1,"stats":{"Line":1}},{"line":104,"address":[5919737],"length":1,"stats":{"Line":1}},{"line":107,"address":[5919839],"length":1,"stats":{"Line":1}},{"line":111,"address":[5915424,5915825],"length":1,"stats":{"Line":1}},{"line":112,"address":[5915454,5915630,5915504],"length":1,"stats":{"Line":2}},{"line":113,"address":[5915581,5915602],"length":1,"stats":{"Line":1}},{"line":114,"address":[5915614],"length":1,"stats":{"Line":1}},{"line":115,"address":[5915703],"length":1,"stats":{"Line":1}},{"line":119,"address":[5915667],"length":1,"stats":{"Line":1}},{"line":123,"address":[5916992],"length":1,"stats":{"Line":1}},{"line":124,"address":[5917023,5917151],"length":1,"stats":{"Line":2}},{"line":127,"address":[5862227,5862369,5862208,5862330,5862276],"length":1,"stats":{"Line":5}},{"line":129,"address":[5917169],"length":1,"stats":{"Line":1}},{"line":130,"address":[5917280,5917398,5917346],"length":1,"stats":{"Line":2}},{"line":137,"address":[5917232],"length":1,"stats":{"Line":1}},{"line":141,"address":[5915920],"length":1,"stats":{"Line":1}},{"line":142,"address":[5915955,5916083],"length":1,"stats":{"Line":2}},{"line":145,"address":[5916130],"length":1,"stats":{"Line":5}},{"line":147,"address":[5916101],"length":1,"stats":{"Line":1}},{"line":148,"address":[5916166,5916232,5916284],"length":1,"stats":{"Line":2}},{"line":155,"address":[5916118],"length":1,"stats":{"Line":1}},{"line":159,"address":[5916384,5916966],"length":1,"stats":{"Line":1}},{"line":160,"address":[5916555],"length":1,"stats":{"Line":1}},{"line":163,"address":[5862003,5862145,5861984,5862052,5862106],"length":1,"stats":{"Line":5}},{"line":165,"address":[5916573],"length":1,"stats":{"Line":1}},{"line":166,"address":[5916651,5916790,5916827],"length":1,"stats":{"Line":0}},{"line":172,"address":[5916575],"length":1,"stats":{"Line":1}},{"line":173,"address":[5916604],"length":1,"stats":{"Line":1}},{"line":177,"address":[5917600],"length":1,"stats":{"Line":1}},{"line":178,"address":[5917642,5917765],"length":1,"stats":{"Line":2}},{"line":181,"address":[5862656,5862778,5862724,5862817,5862675],"length":1,"stats":{"Line":5}},{"line":183,"address":[5917779],"length":1,"stats":{"Line":1}},{"line":184,"address":[5918050,5917981],"length":1,"stats":{"Line":0}},{"line":193,"address":[5917855],"length":1,"stats":{"Line":1}},{"line":194,"address":[5917812],"length":1,"stats":{"Line":1}},{"line":195,"address":[5917824],"length":1,"stats":{"Line":1}},{"line":196,"address":[5917832],"length":1,"stats":{"Line":1}},{"line":199,"address":[5917934],"length":1,"stats":{"Line":1}},{"line":203,"address":[5920032],"length":1,"stats":{"Line":1}},{"line":204,"address":[5920197,5920063],"length":1,"stats":{"Line":2}},{"line":207,"address":[5863444,5863376,5863537,5863498,5863395],"length":1,"stats":{"Line":5}},{"line":209,"address":[5920223,5920211],"length":1,"stats":{"Line":2}},{"line":218,"address":[5918960],"length":1,"stats":{"Line":1}},{"line":219,"address":[5918991,5919119],"length":1,"stats":{"Line":2}},{"line":222,"address":[5919161],"length":1,"stats":{"Line":5}},{"line":224,"address":[5919143,5919129],"length":1,"stats":{"Line":2}},{"line":225,"address":[5919308,5919256,5919190],"length":1,"stats":{"Line":0}},{"line":231,"address":[5919145],"length":1,"stats":{"Line":1}},{"line":232,"address":[5919149],"length":1,"stats":{"Line":1}},{"line":236,"address":[5917488],"length":1,"stats":{"Line":0}},{"line":237,"address":[5917510],"length":1,"stats":{"Line":0}},{"line":239,"address":[5862593,5862432,5862500,5862451,5862554],"length":1,"stats":{"Line":4}},{"line":244,"address":[5915852],"length":1,"stats":{"Line":0}},{"line":258,"address":[5915200],"length":1,"stats":{"Line":0}},{"line":261,"address":[5863699],"length":1,"stats":{"Line":0}},{"line":272,"address":[5915312],"length":1,"stats":{"Line":0}},{"line":275,"address":[5829995],"length":1,"stats":{"Line":1}},{"line":281,"address":[5920528],"length":1,"stats":{"Line":0}}],"covered":65,"coverable":76},{"path":["/","home","user","jeeves-core","src","kernel","mod.rs"],"content":"//! Kernel - the main orchestration actor.\n//!\n//! The Kernel owns all mutable state and processes gRPC commands via a single\n//! message channel. Subsystems (lifecycle, resources, interrupts, rate limiter)\n//! are plain structs owned by the Kernel, not separate actors.\n\nuse std::collections::HashMap;\n\n// Core types\npub mod types;\n\n// Subsystem modules\npub mod interrupts;\npub mod lifecycle;\npub mod orchestrator;\npub mod rate_limiter;\npub mod resources;\npub mod services;\n\n// Re-export key types\npub use interrupts::{InterruptConfig, InterruptService, InterruptStatus, KernelInterrupt};\npub use lifecycle::LifecycleManager;\npub use rate_limiter::{RateLimitConfig, RateLimiter};\npub use resources::ResourceTracker;\npub use services::{\n    DispatchResult, DispatchTarget, RegistryStats, ServiceInfo, ServiceRegistry, ServiceStats,\n    ServiceStatus,\n};\npub use types::{\n    ProcessControlBlock, ProcessState, ResourceQuota, ResourceUsage, SchedulingPriority,\n};\n\nuse crate::envelope::{Envelope, FlowInterrupt, InterruptResponse};\nuse crate::types::{Error, Result};\n\n/// Kernel - the main orchestrator.\n///\n/// Owns all subsystems and provides unified interface for process management.\n/// NOT an actor in the message-passing sense - called directly via \u0026mut self.\n#[derive(Debug)]\npub struct Kernel {\n    /// Process lifecycle management\n    pub lifecycle: LifecycleManager,\n\n    /// Resource tracking and quota enforcement\n    pub resources: ResourceTracker,\n\n    /// Rate limiting per user\n    pub rate_limiter: RateLimiter,\n\n    /// Interrupt handling (human-in-the-loop)\n    pub interrupts: interrupts::InterruptService,\n\n    /// Service registry (IPC and dispatch)\n    pub services: services::ServiceRegistry,\n\n    /// Pipeline orchestration (kernel-driven execution)\n    pub orchestrator: orchestrator::Orchestrator,\n\n    /// Envelope storage (pid -\u003e envelope)\n    envelopes: HashMap\u003cString, Envelope\u003e,\n}\n\nimpl Kernel {\n    pub fn new() -\u003e Self {\n        Self {\n            lifecycle: LifecycleManager::default(),\n            resources: ResourceTracker::default(),\n            rate_limiter: RateLimiter::default(),\n            interrupts: interrupts::InterruptService::new(),\n            services: services::ServiceRegistry::new(),\n            orchestrator: orchestrator::Orchestrator::new(),\n            envelopes: HashMap::new(),\n        }\n    }\n\n    pub fn with_config(\n        default_quota: Option\u003cResourceQuota\u003e,\n        rate_limit_config: Option\u003cRateLimitConfig\u003e,\n    ) -\u003e Self {\n        Self {\n            lifecycle: LifecycleManager::new(default_quota),\n            resources: ResourceTracker::new(),\n            rate_limiter: RateLimiter::new(rate_limit_config),\n            interrupts: interrupts::InterruptService::new(),\n            services: services::ServiceRegistry::new(),\n            orchestrator: orchestrator::Orchestrator::new(),\n            envelopes: HashMap::new(),\n        }\n    }\n\n    /// Create a new process for an envelope.\n    pub fn create_process(\n        \u0026mut self,\n        envelope_id: String,\n        request_id: String,\n        user_id: String,\n        session_id: String,\n        priority: SchedulingPriority,\n        quota: Option\u003cResourceQuota\u003e,\n    ) -\u003e Result\u003cProcessControlBlock\u003e {\n        // Check rate limit\n        self.rate_limiter.check_rate_limit(\u0026user_id)?;\n\n        // Submit process to lifecycle manager\n        let pcb = self.lifecycle.submit(\n            envelope_id.clone(),\n            request_id,\n            user_id,\n            session_id,\n            priority,\n            quota,\n        )?;\n\n        // Schedule it\n        self.lifecycle.schedule(\u0026envelope_id)?;\n\n        Ok(pcb)\n    }\n\n    /// Get process by PID.\n    pub fn get_process(\u0026self, pid: \u0026str) -\u003e Option\u003c\u0026ProcessControlBlock\u003e {\n        self.lifecycle.get(pid)\n    }\n\n    /// Store envelope.\n    pub fn store_envelope(\u0026mut self, envelope: Envelope) {\n        self.envelopes\n            .insert(envelope.envelope_id.clone(), envelope);\n    }\n\n    /// Get envelope by ID.\n    pub fn get_envelope(\u0026self, envelope_id: \u0026str) -\u003e Option\u003c\u0026Envelope\u003e {\n        self.envelopes.get(envelope_id)\n    }\n\n    /// Get mutable envelope by ID.\n    pub fn get_envelope_mut(\u0026mut self, envelope_id: \u0026str) -\u003e Option\u003c\u0026mut Envelope\u003e {\n        self.envelopes.get_mut(envelope_id)\n    }\n\n    /// Remove envelope.\n    pub fn remove_envelope(\u0026mut self, envelope_id: \u0026str) -\u003e Option\u003cEnvelope\u003e {\n        self.envelopes.remove(envelope_id)\n    }\n\n    /// Check process quota.\n    pub fn check_quota(\u0026self, pid: \u0026str) -\u003e Result\u003c()\u003e {\n        let pcb = self\n            .lifecycle\n            .get(pid)\n            .ok_or_else(|| Error::not_found(format!(\"Process {} not found\", pid)))?;\n        self.resources.check_quota(pcb)\n    }\n\n    /// Record resource usage.\n    pub fn record_usage(\n        \u0026mut self,\n        user_id: \u0026str,\n        llm_calls: i32,\n        tool_calls: i32,\n        tokens_in: i64,\n        tokens_out: i64,\n    ) {\n        self.resources\n            .record_usage(user_id, llm_calls, tool_calls, tokens_in, tokens_out);\n    }\n\n    /// Get next runnable process.\n    pub fn get_next_runnable(\u0026mut self) -\u003e Option\u003cProcessControlBlock\u003e {\n        self.lifecycle.get_next_runnable()\n    }\n\n    /// Start a process.\n    pub fn start_process(\u0026mut self, pid: \u0026str) -\u003e Result\u003c()\u003e {\n        self.lifecycle.start(pid)\n    }\n\n    /// Block a process (e.g., resource exhausted).\n    pub fn block_process(\u0026mut self, pid: \u0026str, reason: String) -\u003e Result\u003c()\u003e {\n        self.lifecycle.block(pid, reason)\n    }\n\n    /// Wait a process (e.g., awaiting interrupt response).\n    pub fn wait_process(\u0026mut self, pid: \u0026str, interrupt: FlowInterrupt) -\u003e Result\u003c()\u003e {\n        self.lifecycle.wait(pid, interrupt.kind)?;\n        // Also set interrupt on envelope\n        if let Some(env) = self.envelopes.get_mut(pid) {\n            env.set_interrupt(interrupt);\n        }\n        Ok(())\n    }\n\n    /// Resume a process from waiting/blocked.\n    pub fn resume_process(\u0026mut self, pid: \u0026str) -\u003e Result\u003c()\u003e {\n        self.lifecycle.resume(pid)?;\n        // Clear interrupt on envelope\n        if let Some(env) = self.envelopes.get_mut(pid) {\n            env.clear_interrupt();\n        }\n        Ok(())\n    }\n\n    /// Terminate a process.\n    pub fn terminate_process(\u0026mut self, pid: \u0026str) -\u003e Result\u003c()\u003e {\n        self.lifecycle.terminate(pid)?;\n        // Terminate envelope\n        if let Some(env) = self.envelopes.get_mut(pid) {\n            env.terminate(\"Process terminated\");\n        }\n        Ok(())\n    }\n\n    /// Cleanup and remove a terminated process.\n    pub fn cleanup_process(\u0026mut self, pid: \u0026str) -\u003e Result\u003c()\u003e {\n        self.lifecycle.cleanup(pid)?;\n        self.lifecycle.remove(pid)?;\n        self.envelopes.remove(pid);\n        Ok(())\n    }\n\n    /// List all processes.\n    pub fn list_processes(\u0026self) -\u003e Vec\u003cProcessControlBlock\u003e {\n        self.lifecycle.list()\n    }\n\n    /// Count processes.\n    pub fn process_count(\u0026self) -\u003e usize {\n        self.lifecycle.count()\n    }\n\n    /// Count processes by state.\n    pub fn process_count_by_state(\u0026self, state: ProcessState) -\u003e usize {\n        self.lifecycle.count_by_state(state)\n    }\n\n    // =============================================================================\n    // Interrupt Methods (Delegation to InterruptService)\n    // =============================================================================\n\n    /// Create a new interrupt for a process.\n    pub fn create_interrupt(\n        \u0026mut self,\n        kind: crate::envelope::InterruptKind,\n        request_id: String,\n        user_id: String,\n        session_id: String,\n        envelope_id: String,\n        question: Option\u003cString\u003e,\n        message: Option\u003cString\u003e,\n        data: Option\u003cHashMap\u003cString, serde_json::Value\u003e\u003e,\n    ) -\u003e interrupts::KernelInterrupt {\n        self.interrupts.create_interrupt(\n            kind,\n            request_id,\n            user_id,\n            session_id,\n            envelope_id,\n            question,\n            message,\n            data,\n            None, // trace_id\n            None, // span_id\n        )\n    }\n\n    /// Resolve an interrupt with a response.\n    pub fn resolve_interrupt(\n        \u0026mut self,\n        interrupt_id: \u0026str,\n        response: InterruptResponse,\n        user_id: Option\u003c\u0026str\u003e,\n    ) -\u003e bool {\n        self.interrupts.resolve(interrupt_id, response, user_id)\n    }\n\n    /// Get the most recent pending interrupt for a request.\n    pub fn get_pending_interrupt(\u0026self, request_id: \u0026str) -\u003e Option\u003c\u0026interrupts::KernelInterrupt\u003e {\n        self.interrupts.get_pending_for_request(request_id)\n    }\n\n    // =============================================================================\n    // Service Methods (Delegation to ServiceRegistry)\n    // =============================================================================\n\n    /// Register a service.\n    pub fn register_service(\u0026mut self, info: services::ServiceInfo) -\u003e bool {\n        self.services.register_service(info)\n    }\n\n    /// Unregister a service.\n    pub fn unregister_service(\u0026mut self, service_name: \u0026str) -\u003e bool {\n        self.services.unregister_service(service_name)\n    }\n\n    /// Dispatch a request to a service.\n    pub fn dispatch(\n        \u0026mut self,\n        target: \u0026services::DispatchTarget,\n        data: \u0026HashMap\u003cString, serde_json::Value\u003e,\n    ) -\u003e Result\u003cservices::DispatchResult\u003e {\n        self.services\n            .dispatch(target, data)\n            .map_err(|e| Error::internal(e))\n    }\n\n    // =============================================================================\n    // Orchestrator Methods (Delegation to Orchestrator)\n    // =============================================================================\n\n    /// Initialize an orchestration session.\n    pub fn initialize_orchestration(\n        \u0026mut self,\n        process_id: String,\n        pipeline_config: orchestrator::PipelineConfig,\n        envelope: Envelope,\n        force: bool,\n    ) -\u003e Result\u003corchestrator::SessionState\u003e {\n        self.orchestrator\n            .initialize_session(process_id, pipeline_config, envelope, force)\n            .map_err(|e| Error::internal(e))\n    }\n\n    /// Get the next instruction for a process.\n    pub fn get_next_instruction(\n        \u0026mut self,\n        process_id: \u0026str,\n    ) -\u003e Result\u003corchestrator::Instruction\u003e {\n        self.orchestrator\n            .get_next_instruction(process_id)\n            .map_err(|e| Error::internal(e))\n    }\n\n    /// Report agent execution result.\n    pub fn report_agent_result(\n        \u0026mut self,\n        process_id: \u0026str,\n        metrics: orchestrator::AgentExecutionMetrics,\n        updated_envelope: Envelope,\n    ) -\u003e Result\u003c()\u003e {\n        self.orchestrator\n            .report_agent_result(process_id, metrics, updated_envelope)\n            .map_err(|e| Error::internal(e))\n    }\n\n    /// Get orchestration session state.\n    pub fn get_orchestration_state(\u0026self, process_id: \u0026str) -\u003e Result\u003corchestrator::SessionState\u003e {\n        self.orchestrator\n            .get_session_state(process_id)\n            .map_err(|e| Error::internal(e))\n    }\n\n    // =============================================================================\n    // Resource Tracking (Additional Methods)\n    // =============================================================================\n\n    /// Record a tool call for a process.\n    pub fn record_tool_call(\u0026mut self, pid: \u0026str) -\u003e Result\u003c()\u003e {\n        if let Some(pcb) = self.lifecycle.get_mut(pid) {\n            pcb.usage.tool_calls += 1;\n        }\n        if let Some(env) = self.envelopes.get_mut(pid) {\n            env.tool_call_count += 1;\n        }\n        Ok(())\n    }\n\n    /// Record an agent hop for a process.\n    pub fn record_agent_hop(\u0026mut self, pid: \u0026str) -\u003e Result\u003c()\u003e {\n        if let Some(pcb) = self.lifecycle.get_mut(pid) {\n            pcb.usage.agent_hops += 1;\n        }\n        if let Some(env) = self.envelopes.get_mut(pid) {\n            env.agent_hop_count += 1;\n        }\n        Ok(())\n    }\n\n    /// Get remaining resource budget for a process.\n    pub fn get_remaining_budget(\u0026self, pid: \u0026str) -\u003e Option\u003cRemainingBudget\u003e {\n        let pcb = self.lifecycle.get(pid)?;\n        Some(RemainingBudget {\n            llm_calls_remaining: (pcb.quota.max_llm_calls - pcb.usage.llm_calls).max(0),\n            iterations_remaining: (pcb.quota.max_iterations - pcb.usage.iterations).max(0),\n            agent_hops_remaining: (pcb.quota.max_agent_hops - pcb.usage.agent_hops).max(0),\n            tokens_in_remaining: (pcb.quota.max_input_tokens as i64 - pcb.usage.tokens_in).max(0),\n            tokens_out_remaining: (pcb.quota.max_output_tokens as i64 - pcb.usage.tokens_out)\n                .max(0),\n            time_remaining_seconds: if pcb.quota.timeout_seconds \u003e 0 {\n                (pcb.quota.timeout_seconds as f64 - pcb.usage.elapsed_seconds).max(0.0)\n            } else {\n                f64::MAX\n            },\n        })\n    }\n}\n\n/// Remaining resource budget for a process.\n#[derive(Debug, Clone)]\npub struct RemainingBudget {\n    pub llm_calls_remaining: i32,\n    pub iterations_remaining: i32,\n    pub agent_hops_remaining: i32,\n    pub tokens_in_remaining: i64,\n    pub tokens_out_remaining: i64,\n    pub time_remaining_seconds: f64,\n}\n\nimpl Default for Kernel {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","jeeves-core","src","kernel","orchestrator.rs"],"content":"//! Pipeline orchestration - kernel-driven pipeline execution control.\n//!\n//! The Orchestrator:\n//!   - Owns the orchestration loop (moved from Python)\n//!   - Evaluates routing rules\n//!   - Tracks edge traversals\n//!   - Enforces bounds (iterations, LLM calls, agent hops)\n//!   - Returns Instructions to Python workers\n//!\n//! Python workers:\n//!   - Execute agents (LLM calls, tool execution)\n//!   - Report results back\n//!   - Have NO control over what runs next\n\nuse crate::envelope::{Envelope, FlowInterrupt, TerminalReason};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n// =============================================================================\n// Instruction Types\n// =============================================================================\n\n/// InstructionKind indicates what the Python worker should do next.\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum InstructionKind {\n    /// Execute specified agent\n    RunAgent,\n    /// End execution\n    Terminate,\n    /// Wait for interrupt resolution\n    WaitInterrupt,\n}\n\n/// Instruction tells Python worker what to do next.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Instruction {\n    pub kind: InstructionKind,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub agent_name: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub agent_config: Option\u003cserde_json::Value\u003e, // Placeholder for AgentConfig\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub envelope: Option\u003cEnvelope\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub terminal_reason: Option\u003cTerminalReason\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub termination_message: Option\u003cString\u003e,\n    pub interrupt_pending: bool,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub interrupt: Option\u003cFlowInterrupt\u003e,\n}\n\n/// AgentExecutionMetrics contains metrics from agent execution.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AgentExecutionMetrics {\n    pub llm_calls: i32,\n    pub tool_calls: i32,\n    pub tokens_in: i64,\n    pub tokens_out: i64,\n    pub duration_ms: i64,\n}\n\n// =============================================================================\n// Pipeline Config (Simplified)\n// =============================================================================\n\n/// Simplified PipelineConfig for orchestration.\n/// Full implementation would come from config module.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PipelineConfig {\n    pub name: String,\n    pub stages: Vec\u003cPipelineStage\u003e,\n    pub max_iterations: i32,\n    pub max_llm_calls: i32,\n    pub max_agent_hops: i32,\n}\n\nimpl PipelineConfig {\n    /// Get stage order from pipeline.\n    pub fn get_stage_order(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.stages.iter().map(|s| s.name.clone()).collect()\n    }\n\n    /// Validate pipeline configuration.\n    pub fn validate(\u0026self) -\u003e Result\u003c(), String\u003e {\n        if self.name.is_empty() {\n            return Err(\"Pipeline name is required\".to_string());\n        }\n        if self.stages.is_empty() {\n            return Err(\"Pipeline must have at least one stage\".to_string());\n        }\n        Ok(())\n    }\n}\n\n/// Simplified PipelineStage.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PipelineStage {\n    pub name: String,\n    pub agent: String,\n    pub routing: Vec\u003cRoutingRule\u003e,\n}\n\n/// Simplified RoutingRule.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RoutingRule {\n    pub condition: String, // Simplified - full impl would parse this\n    pub target: String,\n    pub priority: i32,\n}\n\n// =============================================================================\n// Orchestration Session\n// =============================================================================\n\n/// OrchestrationSession represents an active pipeline execution session.\n#[derive(Debug, Clone)]\npub struct OrchestrationSession {\n    pub process_id: String,\n    pub pipeline_config: PipelineConfig,\n    pub envelope: Envelope,\n    pub edge_traversals: HashMap\u003cString, i32\u003e, // \"from-\u003eto\" -\u003e count\n    pub terminated: bool,\n    pub terminal_reason: Option\u003cTerminalReason\u003e,\n    pub created_at: DateTime\u003cUtc\u003e,\n    pub last_activity_at: DateTime\u003cUtc\u003e,\n}\n\n/// SessionState is the external representation of session state.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SessionState {\n    pub process_id: String,\n    pub current_stage: String,\n    pub stage_order: Vec\u003cString\u003e,\n    pub envelope: HashMap\u003cString, serde_json::Value\u003e, // Simplified envelope representation\n    pub edge_traversals: HashMap\u003cString, i32\u003e,\n    pub terminated: bool,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub terminal_reason: Option\u003cTerminalReason\u003e,\n}\n\n// =============================================================================\n// Orchestrator\n// =============================================================================\n\n/// Orchestrator manages kernel-side pipeline execution.\n#[derive(Debug)]\npub struct Orchestrator {\n    sessions: HashMap\u003cString, OrchestrationSession\u003e,\n}\n\nimpl Orchestrator {\n    /// Create a new Orchestrator.\n    pub fn new() -\u003e Self {\n        Self {\n            sessions: HashMap::new(),\n        }\n    }\n\n    // =============================================================================\n    // Session Management\n    // =============================================================================\n\n    /// Initialize a new orchestration session.\n    /// If force is false and a session already exists, returns an error.\n    /// If force is true, replaces any existing session.\n    pub fn initialize_session(\n        \u0026mut self,\n        process_id: String,\n        pipeline_config: PipelineConfig,\n        mut envelope: Envelope,\n        force: bool,\n    ) -\u003e Result\u003cSessionState, String\u003e {\n        // Check for duplicate processID\n        if self.sessions.contains_key(\u0026process_id) \u0026\u0026 !force {\n            return Err(format!(\n                \"Session already exists for process: {} (use force=true to replace)\",\n                process_id\n            ));\n        }\n\n        // Validate pipeline config\n        pipeline_config.validate()?;\n\n        // Initialize envelope with pipeline bounds\n        envelope.max_iterations = pipeline_config.max_iterations;\n        envelope.max_llm_calls = pipeline_config.max_llm_calls;\n        envelope.max_agent_hops = pipeline_config.max_agent_hops;\n        envelope.stage_order = pipeline_config.get_stage_order();\n\n        // Set initial stage if not set\n        if envelope.current_stage.is_empty() \u0026\u0026 !envelope.stage_order.is_empty() {\n            envelope.current_stage = envelope.stage_order[0].clone();\n        }\n\n        let now = Utc::now();\n        let session = OrchestrationSession {\n            process_id: process_id.clone(),\n            pipeline_config,\n            envelope,\n            edge_traversals: HashMap::new(),\n            terminated: false,\n            terminal_reason: None,\n            created_at: now,\n            last_activity_at: now,\n        };\n\n        let state = self.build_session_state(\u0026session);\n        self.sessions.insert(process_id, session);\n\n        Ok(state)\n    }\n\n    /// Get the next instruction for a process.\n    pub fn get_next_instruction(\u0026mut self, process_id: \u0026str) -\u003e Result\u003cInstruction, String\u003e {\n        let session = self\n            .sessions\n            .get_mut(process_id)\n            .ok_or_else(|| format!(\"Unknown process: {}\", process_id))?;\n\n        // Update activity timestamp\n        session.last_activity_at = Utc::now();\n\n        // Check if already terminated\n        if session.terminated {\n            return Ok(Instruction {\n                kind: InstructionKind::Terminate,\n                agent_name: None,\n                agent_config: None,\n                envelope: Some(session.envelope.clone()),\n                terminal_reason: session.terminal_reason,\n                termination_message: Some(\"Session already terminated\".to_string()),\n                interrupt_pending: false,\n                interrupt: None,\n            });\n        }\n\n        // Check for pending interrupt\n        if session.envelope.interrupt_pending {\n            return Ok(Instruction {\n                kind: InstructionKind::WaitInterrupt,\n                agent_name: None,\n                agent_config: None,\n                envelope: Some(session.envelope.clone()),\n                terminal_reason: None,\n                termination_message: None,\n                interrupt_pending: true,\n                interrupt: session.envelope.interrupt.clone(),\n            });\n        }\n\n        // Check bounds\n        if let Some(reason) = check_bounds(\u0026session.envelope) {\n            session.terminated = true;\n            session.terminal_reason = Some(reason);\n            return Ok(Instruction {\n                kind: InstructionKind::Terminate,\n                agent_name: None,\n                agent_config: None,\n                envelope: Some(session.envelope.clone()),\n                terminal_reason: Some(reason),\n                termination_message: Some(format!(\"Bounds exceeded: {:?}\", reason)),\n                interrupt_pending: false,\n                interrupt: None,\n            });\n        }\n\n        // Determine next agent to run\n        let current_stage = \u0026session.envelope.current_stage;\n        if current_stage.is_empty() {\n            return Err(\"No current stage set\".to_string());\n        }\n\n        let agent_name = get_agent_for_stage(\u0026session.pipeline_config, current_stage)?;\n\n        Ok(Instruction {\n            kind: InstructionKind::RunAgent,\n            agent_name: Some(agent_name),\n            agent_config: None, // Placeholder\n            envelope: Some(session.envelope.clone()),\n            terminal_reason: None,\n            termination_message: None,\n            interrupt_pending: false,\n            interrupt: None,\n        })\n    }\n\n    /// Process agent execution result.\n    pub fn report_agent_result(\n        \u0026mut self,\n        process_id: \u0026str,\n        metrics: AgentExecutionMetrics,\n        updated_envelope: Envelope,\n    ) -\u003e Result\u003c(), String\u003e {\n        let session = self\n            .sessions\n            .get_mut(process_id)\n            .ok_or_else(|| format!(\"Unknown process: {}\", process_id))?;\n\n        // Update envelope\n        session.envelope = updated_envelope;\n\n        // Update metrics in envelope\n        session.envelope.llm_call_count += metrics.llm_calls;\n        session.envelope.tool_call_count += metrics.tool_calls;\n        session.envelope.tokens_in += metrics.tokens_in;\n        session.envelope.tokens_out += metrics.tokens_out;\n\n        // Increment iteration\n        session.envelope.iteration += 1;\n\n        // Update activity timestamp\n        session.last_activity_at = Utc::now();\n\n        Ok(())\n    }\n\n    /// Get session state for external queries.\n    pub fn get_session_state(\u0026self, process_id: \u0026str) -\u003e Result\u003cSessionState, String\u003e {\n        let session = self\n            .sessions\n            .get(process_id)\n            .ok_or_else(|| format!(\"Unknown process: {}\", process_id))?;\n\n        Ok(self.build_session_state(session))\n    }\n\n    /// Cleanup a session.\n    pub fn cleanup_session(\u0026mut self, process_id: \u0026str) -\u003e bool {\n        self.sessions.remove(process_id).is_some()\n    }\n\n    /// Get session count.\n    pub fn get_session_count(\u0026self) -\u003e usize {\n        self.sessions.len()\n    }\n\n    /// Cleanup stale sessions older than the given duration.\n    pub fn cleanup_stale_sessions(\u0026mut self, max_age_seconds: i64) -\u003e usize {\n        let cutoff = Utc::now() - chrono::Duration::seconds(max_age_seconds);\n        let mut to_remove = Vec::new();\n\n        for (pid, session) in \u0026self.sessions {\n            if session.last_activity_at \u003c cutoff {\n                to_remove.push(pid.clone());\n            }\n        }\n\n        let count = to_remove.len();\n        for pid in to_remove {\n            self.sessions.remove(\u0026pid);\n        }\n\n        count\n    }\n\n    // =============================================================================\n    // Internal Helpers\n    // =============================================================================\n\n    /// Build external session state representation.\n    fn build_session_state(\u0026self, session: \u0026OrchestrationSession) -\u003e SessionState {\n        SessionState {\n            process_id: session.process_id.clone(),\n            current_stage: session.envelope.current_stage.clone(),\n            stage_order: session.envelope.stage_order.clone(),\n            envelope: HashMap::new(), // Simplified - full impl would serialize envelope\n            edge_traversals: session.edge_traversals.clone(),\n            terminated: session.terminated,\n            terminal_reason: session.terminal_reason,\n        }\n    }\n}\n\nimpl Default for Orchestrator {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n// =============================================================================\n// Helper Functions (outside impl to avoid borrow checker issues)\n// =============================================================================\n\n/// Check if envelope exceeds bounds.\nfn check_bounds(envelope: \u0026Envelope) -\u003e Option\u003cTerminalReason\u003e {\n    if envelope.llm_call_count \u003e= envelope.max_llm_calls {\n        return Some(TerminalReason::MaxLlmCallsExceeded);\n    }\n    if envelope.iteration \u003e= envelope.max_iterations {\n        return Some(TerminalReason::MaxIterationsExceeded);\n    }\n    if envelope.agent_hop_count \u003e= envelope.max_agent_hops {\n        return Some(TerminalReason::MaxAgentHopsExceeded);\n    }\n    None\n}\n\n/// Get agent name for a stage.\nfn get_agent_for_stage(\n    pipeline_config: \u0026PipelineConfig,\n    stage_name: \u0026str,\n) -\u003e Result\u003cString, String\u003e {\n    pipeline_config\n        .stages\n        .iter()\n        .find(|s| s.name == stage_name)\n        .map(|s| s.agent.clone())\n        .ok_or_else(|| format!(\"Stage not found in pipeline: {}\", stage_name))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn create_test_pipeline() -\u003e PipelineConfig {\n        PipelineConfig {\n            name: \"test_pipeline\".to_string(),\n            stages: vec![\n                PipelineStage {\n                    name: \"stage1\".to_string(),\n                    agent: \"agent1\".to_string(),\n                    routing: vec![],\n                },\n                PipelineStage {\n                    name: \"stage2\".to_string(),\n                    agent: \"agent2\".to_string(),\n                    routing: vec![],\n                },\n            ],\n            max_iterations: 10,\n            max_llm_calls: 50,\n            max_agent_hops: 5,\n        }\n    }\n\n    fn create_test_envelope() -\u003e Envelope {\n        let mut env = Envelope::new();\n        env.current_stage = String::new(); // Clear so initialize_session sets it\n        env\n    }\n\n    #[test]\n    fn test_initialize_session() {\n        let mut orch = Orchestrator::new();\n        let pipeline = create_test_pipeline();\n        let envelope = create_test_envelope();\n\n        let state = orch\n            .initialize_session(\"proc1\".to_string(), pipeline.clone(), envelope, false)\n            .unwrap();\n\n        assert_eq!(state.process_id, \"proc1\");\n        assert_eq!(state.current_stage, \"stage1\"); // First stage\n        assert_eq!(state.stage_order, vec![\"stage1\", \"stage2\"]);\n        assert!(!state.terminated);\n    }\n\n    #[test]\n    fn test_initialize_session_duplicate_fails() {\n        let mut orch = Orchestrator::new();\n        let pipeline = create_test_pipeline();\n        let envelope = create_test_envelope();\n\n        // Initialize first time\n        orch.initialize_session(\"proc1\".to_string(), pipeline.clone(), envelope.clone(), false)\n            .unwrap();\n\n        // Try to initialize again without force\n        let result =\n            orch.initialize_session(\"proc1\".to_string(), pipeline, envelope, false);\n\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"already exists\"));\n    }\n\n    #[test]\n    fn test_initialize_session_force_replaces() {\n        let mut orch = Orchestrator::new();\n        let pipeline = create_test_pipeline();\n        let envelope = create_test_envelope();\n\n        // Initialize first time\n        orch.initialize_session(\"proc1\".to_string(), pipeline.clone(), envelope.clone(), false)\n            .unwrap();\n\n        // Initialize again with force=true should succeed\n        let result =\n            orch.initialize_session(\"proc1\".to_string(), pipeline, envelope, true);\n\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_get_next_instruction_run_agent() {\n        let mut orch = Orchestrator::new();\n        let pipeline = create_test_pipeline();\n        let envelope = create_test_envelope();\n\n        orch.initialize_session(\"proc1\".to_string(), pipeline, envelope, false)\n            .unwrap();\n\n        let instruction = orch.get_next_instruction(\"proc1\").unwrap();\n\n        assert_eq!(instruction.kind, InstructionKind::RunAgent);\n        assert_eq!(instruction.agent_name, Some(\"agent1\".to_string()));\n        assert!(!instruction.interrupt_pending);\n    }\n\n    #[test]\n    fn test_get_next_instruction_terminate_after_terminated() {\n        let mut orch = Orchestrator::new();\n        let pipeline = create_test_pipeline();\n        let envelope = create_test_envelope();\n\n        orch.initialize_session(\"proc1\".to_string(), pipeline, envelope, false)\n            .unwrap();\n\n        // Manually terminate session\n        let session = orch.sessions.get_mut(\"proc1\").unwrap();\n        session.terminated = true;\n        session.terminal_reason = Some(TerminalReason::MaxIterationsExceeded);\n\n        let instruction = orch.get_next_instruction(\"proc1\").unwrap();\n\n        assert_eq!(instruction.kind, InstructionKind::Terminate);\n        assert_eq!(\n            instruction.terminal_reason,\n            Some(TerminalReason::MaxIterationsExceeded)\n        );\n    }\n\n    #[test]\n    fn test_get_next_instruction_wait_interrupt() {\n        let mut orch = Orchestrator::new();\n        let pipeline = create_test_pipeline();\n        let mut envelope = create_test_envelope();\n\n        // Set interrupt pending\n        envelope.interrupt_pending = true;\n        envelope.interrupt = Some(\n            FlowInterrupt::new(crate::envelope::InterruptKind::Clarification)\n                .with_message(\"Need clarification\".to_string())\n        );\n\n        orch.initialize_session(\"proc1\".to_string(), pipeline, envelope, false)\n            .unwrap();\n\n        let instruction = orch.get_next_instruction(\"proc1\").unwrap();\n\n        assert_eq!(instruction.kind, InstructionKind::WaitInterrupt);\n        assert!(instruction.interrupt_pending);\n        assert!(instruction.interrupt.is_some());\n    }\n\n    #[test]\n    fn test_check_bounds_llm_exceeded() {\n        let mut orch = Orchestrator::new();\n        let pipeline = create_test_pipeline();\n        let envelope = create_test_envelope();\n\n        orch.initialize_session(\"proc1\".to_string(), pipeline, envelope, false)\n            .unwrap();\n\n        // Manually exceed LLM calls\n        let session = orch.sessions.get_mut(\"proc1\").unwrap();\n        session.envelope.llm_call_count = 50; // At limit\n        session.envelope.max_llm_calls = 50;\n\n        let instruction = orch.get_next_instruction(\"proc1\").unwrap();\n\n        assert_eq!(instruction.kind, InstructionKind::Terminate);\n        assert_eq!(\n            instruction.terminal_reason,\n            Some(TerminalReason::MaxLlmCallsExceeded)\n        );\n    }\n\n    #[test]\n    fn test_check_bounds_iterations_exceeded() {\n        let mut orch = Orchestrator::new();\n        let pipeline = create_test_pipeline();\n        let envelope = create_test_envelope();\n\n        orch.initialize_session(\"proc1\".to_string(), pipeline, envelope, false)\n            .unwrap();\n\n        // Manually exceed iterations\n        let session = orch.sessions.get_mut(\"proc1\").unwrap();\n        session.envelope.iteration = 10; // At limit\n        session.envelope.max_iterations = 10;\n\n        let instruction = orch.get_next_instruction(\"proc1\").unwrap();\n\n        assert_eq!(instruction.kind, InstructionKind::Terminate);\n        assert_eq!(\n            instruction.terminal_reason,\n            Some(TerminalReason::MaxIterationsExceeded)\n        );\n    }\n\n    #[test]\n    fn test_report_agent_result_updates_metrics() {\n        let mut orch = Orchestrator::new();\n        let pipeline = create_test_pipeline();\n        let envelope = create_test_envelope();\n\n        orch.initialize_session(\"proc1\".to_string(), pipeline, envelope.clone(), false)\n            .unwrap();\n\n        let metrics = AgentExecutionMetrics {\n            llm_calls: 2,\n            tool_calls: 5,\n            tokens_in: 1000,\n            tokens_out: 500,\n            duration_ms: 1500,\n        };\n\n        orch.report_agent_result(\"proc1\", metrics, envelope)\n            .unwrap();\n\n        // Check metrics were updated\n        let session = orch.sessions.get(\"proc1\").unwrap();\n        assert_eq!(session.envelope.llm_call_count, 2);\n        assert_eq!(session.envelope.tool_call_count, 5);\n        assert_eq!(session.envelope.tokens_in, 1000);\n        assert_eq!(session.envelope.tokens_out, 500);\n        assert_eq!(session.envelope.iteration, 1); // Incremented\n    }\n\n    #[test]\n    fn test_get_session_state() {\n        let mut orch = Orchestrator::new();\n        let pipeline = create_test_pipeline();\n        let envelope = create_test_envelope();\n\n        orch.initialize_session(\"proc1\".to_string(), pipeline, envelope, false)\n            .unwrap();\n\n        let state = orch.get_session_state(\"proc1\").unwrap();\n\n        assert_eq!(state.process_id, \"proc1\");\n        assert_eq!(state.current_stage, \"stage1\");\n        assert!(!state.terminated);\n    }\n\n    #[test]\n    fn test_cleanup_session() {\n        let mut orch = Orchestrator::new();\n        let pipeline = create_test_pipeline();\n        let envelope = create_test_envelope();\n\n        orch.initialize_session(\"proc1\".to_string(), pipeline, envelope, false)\n            .unwrap();\n\n        assert_eq!(orch.get_session_count(), 1);\n\n        let removed = orch.cleanup_session(\"proc1\");\n        assert!(removed);\n        assert_eq!(orch.get_session_count(), 0);\n\n        // Second cleanup should return false\n        let removed = orch.cleanup_session(\"proc1\");\n        assert!(!removed);\n    }\n\n    #[test]\n    fn test_get_session_state_not_found() {\n        let orch = Orchestrator::new();\n\n        let result = orch.get_session_state(\"nonexistent\");\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"Unknown process\"));\n    }\n\n    #[test]\n    fn test_pipeline_validation() {\n        let mut pipeline = create_test_pipeline();\n\n        // Valid pipeline\n        assert!(pipeline.validate().is_ok());\n\n        // Empty name\n        pipeline.name = String::new();\n        assert!(pipeline.validate().is_err());\n\n        // Empty stages\n        let mut pipeline2 = create_test_pipeline();\n        pipeline2.stages = vec![];\n        assert!(pipeline2.validate().is_err());\n    }\n}\n","traces":[{"line":83,"address":[5921440],"length":1,"stats":{"Line":1}},{"line":87,"address":[5852176],"length":1,"stats":{"Line":0}},{"line":88,"address":[5846533,5852182],"length":1,"stats":{"Line":3}},{"line":89,"address":[5852209],"length":1,"stats":{"Line":1}},{"line":91,"address":[5852189,5846544],"length":1,"stats":{"Line":3}},{"line":92,"address":[5852223],"length":1,"stats":{"Line":0}},{"line":94,"address":[5846550,5852201],"length":1,"stats":{"Line":2}},{"line":156,"address":[5852112],"length":1,"stats":{"Line":0}},{"line":169,"address":[5846336,5848469],"length":1,"stats":{"Line":1}},{"line":177,"address":[5846413],"length":1,"stats":{"Line":1}},{"line":178,"address":[5846439,5846632],"length":1,"stats":{"Line":2}},{"line":185,"address":[5846740,5847570],"length":1,"stats":{"Line":1}},{"line":188,"address":[5846760],"length":1,"stats":{"Line":1}},{"line":189,"address":[5846775],"length":1,"stats":{"Line":1}},{"line":190,"address":[5846785],"length":1,"stats":{"Line":1}},{"line":191,"address":[5846902,5846877],"length":1,"stats":{"Line":2}},{"line":194,"address":[5846939],"length":1,"stats":{"Line":1}},{"line":195,"address":[5847036,5847072],"length":1,"stats":{"Line":2}},{"line":198,"address":[5847101],"length":1,"stats":{"Line":1}},{"line":200,"address":[5847112],"length":1,"stats":{"Line":1}},{"line":210,"address":[5847440],"length":1,"stats":{"Line":1}},{"line":211,"address":[5847445],"length":1,"stats":{"Line":1}},{"line":213,"address":[5847554],"length":1,"stats":{"Line":1}},{"line":217,"address":[5849584,5852101],"length":1,"stats":{"Line":1}},{"line":218,"address":[5849886],"length":1,"stats":{"Line":1}},{"line":221,"address":[5849861,5849739,5849794],"length":1,"stats":{"Line":0}},{"line":224,"address":[5849903],"length":1,"stats":{"Line":1}},{"line":227,"address":[5849938],"length":1,"stats":{"Line":1}},{"line":228,"address":[5850066],"length":1,"stats":{"Line":1}},{"line":230,"address":[5849952],"length":1,"stats":{"Line":1}},{"line":231,"address":[5849957],"length":1,"stats":{"Line":1}},{"line":232,"address":[5849965],"length":1,"stats":{"Line":1}},{"line":233,"address":[5850009],"length":1,"stats":{"Line":1}},{"line":234,"address":[5850017],"length":1,"stats":{"Line":1}},{"line":241,"address":[5850274],"length":1,"stats":{"Line":1}},{"line":242,"address":[5850845],"length":1,"stats":{"Line":1}},{"line":244,"address":[5850288],"length":1,"stats":{"Line":1}},{"line":245,"address":[5850293],"length":1,"stats":{"Line":1}},{"line":246,"address":[5850306],"length":1,"stats":{"Line":1}},{"line":248,"address":[5850338],"length":1,"stats":{"Line":1}},{"line":250,"address":[5850822],"length":1,"stats":{"Line":1}},{"line":255,"address":[5850675,5850434],"length":1,"stats":{"Line":2}},{"line":256,"address":[5850680],"length":1,"stats":{"Line":1}},{"line":257,"address":[5850688],"length":1,"stats":{"Line":1}},{"line":258,"address":[5851116],"length":1,"stats":{"Line":1}},{"line":260,"address":[5850695],"length":1,"stats":{"Line":1}},{"line":261,"address":[5850700],"length":1,"stats":{"Line":1}},{"line":262,"address":[5850716],"length":1,"stats":{"Line":1}},{"line":264,"address":[5850753,5851084],"length":1,"stats":{"Line":2}},{"line":272,"address":[5850459],"length":1,"stats":{"Line":1}},{"line":273,"address":[5851281],"length":1,"stats":{"Line":0}},{"line":276,"address":[5851751,5851569,5851533],"length":1,"stats":{"Line":2}},{"line":278,"address":[5851610,5851641],"length":1,"stats":{"Line":2}},{"line":281,"address":[5851589],"length":1,"stats":{"Line":1}},{"line":282,"address":[5851605,5851633],"length":1,"stats":{"Line":2}},{"line":291,"address":[5849573,5848880],"length":1,"stats":{"Line":1}},{"line":297,"address":[5849150],"length":1,"stats":{"Line":1}},{"line":300,"address":[5864098,5864003,5863984,5864051],"length":1,"stats":{"Line":0}},{"line":303,"address":[5849530,5849164],"length":1,"stats":{"Line":1}},{"line":306,"address":[5849211],"length":1,"stats":{"Line":1}},{"line":307,"address":[5849235],"length":1,"stats":{"Line":1}},{"line":308,"address":[5849259],"length":1,"stats":{"Line":1}},{"line":309,"address":[5849282],"length":1,"stats":{"Line":1}},{"line":312,"address":[5849306],"length":1,"stats":{"Line":1}},{"line":315,"address":[5849335],"length":1,"stats":{"Line":1}},{"line":317,"address":[5849364],"length":1,"stats":{"Line":1}},{"line":321,"address":[5845984],"length":1,"stats":{"Line":1}},{"line":322,"address":[5846229],"length":1,"stats":{"Line":1}},{"line":325,"address":[5863808,5863827,5863875,5863922],"length":1,"stats":{"Line":2}},{"line":327,"address":[5846234],"length":1,"stats":{"Line":1}},{"line":331,"address":[5845888],"length":1,"stats":{"Line":0}},{"line":364,"address":[5848480,5848859],"length":1,"stats":{"Line":1}},{"line":366,"address":[5848500],"length":1,"stats":{"Line":1}},{"line":367,"address":[5848518],"length":1,"stats":{"Line":1}},{"line":368,"address":[5848533],"length":1,"stats":{"Line":1}},{"line":370,"address":[5848597],"length":1,"stats":{"Line":1}},{"line":371,"address":[5848644],"length":1,"stats":{"Line":1}},{"line":388,"address":[5850414,5850423],"length":1,"stats":{"Line":2}},{"line":389,"address":[5850369],"length":1,"stats":{"Line":1}},{"line":392,"address":[5850388],"length":1,"stats":{"Line":1}},{"line":395,"address":[5850407,5850416],"length":1,"stats":{"Line":2}},{"line":409,"address":[5864473,5864400,5864405],"length":1,"stats":{"Line":0}},{"line":410,"address":[5851258],"length":1,"stats":{"Line":1}},{"line":411,"address":[5851485,5851429,5851352],"length":1,"stats":{"Line":0}}],"covered":75,"coverable":84},{"path":["/","home","user","jeeves-core","src","kernel","rate_limiter.rs"],"content":"//! Rate limiting and throttling.\n//!\n//! Simple sliding window rate limiter for API calls.\n\nuse chrono::{DateTime, Duration, Utc};\nuse std::collections::{HashMap, VecDeque};\n\nuse crate::types::{Error, Result};\n\n/// Rate limit window configuration.\n#[derive(Debug, Clone)]\npub struct RateLimitConfig {\n    pub requests_per_minute: u32,\n    pub requests_per_hour: u32,\n    pub burst_size: u32,\n}\n\nimpl Default for RateLimitConfig {\n    fn default() -\u003e Self {\n        Self {\n            requests_per_minute: 60,\n            requests_per_hour: 1000,\n            burst_size: 10,\n        }\n    }\n}\n\n/// Sliding window for tracking requests.\n#[derive(Debug)]\nstruct SlidingWindow {\n    timestamps: VecDeque\u003cDateTime\u003cUtc\u003e\u003e,\n    config: RateLimitConfig,\n}\n\nimpl SlidingWindow {\n    fn new(config: RateLimitConfig) -\u003e Self {\n        Self {\n            timestamps: VecDeque::new(),\n            config,\n        }\n    }\n\n    /// Check if request is allowed under rate limits.\n    fn check_and_record(\u0026mut self, now: DateTime\u003cUtc\u003e) -\u003e Result\u003c()\u003e {\n        // Remove timestamps outside the hour window\n        let hour_ago = now - Duration::hours(1);\n        while let Some(\u0026ts) = self.timestamps.front() {\n            if ts \u003c hour_ago {\n                self.timestamps.pop_front();\n            } else {\n                break;\n            }\n        }\n\n        // Check hour limit\n        if self.timestamps.len() \u003e= self.config.requests_per_hour as usize {\n            return Err(Error::quota_exceeded(format!(\n                \"Rate limit exceeded: {} requests per hour\",\n                self.config.requests_per_hour\n            )));\n        }\n\n        // Check minute limit\n        let minute_ago = now - Duration::minutes(1);\n        let recent_count = self\n            .timestamps\n            .iter()\n            .filter(|\u0026\u0026ts| ts \u003e= minute_ago)\n            .count();\n\n        if recent_count \u003e= self.config.requests_per_minute as usize {\n            return Err(Error::quota_exceeded(format!(\n                \"Rate limit exceeded: {} requests per minute\",\n                self.config.requests_per_minute\n            )));\n        }\n\n        // Check burst limit (last 10 seconds)\n        let ten_seconds_ago = now - Duration::seconds(10);\n        let burst_count = self\n            .timestamps\n            .iter()\n            .filter(|\u0026\u0026ts| ts \u003e= ten_seconds_ago)\n            .count();\n\n        if burst_count \u003e= self.config.burst_size as usize {\n            return Err(Error::quota_exceeded(format!(\n                \"Burst limit exceeded: {} requests per 10 seconds\",\n                self.config.burst_size\n            )));\n        }\n\n        // Record this request\n        self.timestamps.push_back(now);\n        Ok(())\n    }\n}\n\n/// Rate limiter - enforces request rate limits per user.\n///\n/// NOT a separate actor - owned by Kernel and called via \u0026mut self.\n#[derive(Debug)]\npub struct RateLimiter {\n    default_config: RateLimitConfig,\n    user_windows: HashMap\u003cString, SlidingWindow\u003e,\n}\n\nimpl RateLimiter {\n    pub fn new(default_config: Option\u003cRateLimitConfig\u003e) -\u003e Self {\n        Self {\n            default_config: default_config.unwrap_or_default(),\n            user_windows: HashMap::new(),\n        }\n    }\n\n    /// Check rate limit for a user and record the request if allowed.\n    pub fn check_rate_limit(\u0026mut self, user_id: \u0026str) -\u003e Result\u003c()\u003e {\n        let now = Utc::now();\n        let window = self\n            .user_windows\n            .entry(user_id.to_string())\n            .or_insert_with(|| SlidingWindow::new(self.default_config.clone()));\n\n        window.check_and_record(now)\n    }\n\n    /// Get current request count for a user (last minute).\n    pub fn get_current_rate(\u0026self, user_id: \u0026str) -\u003e usize {\n        if let Some(window) = self.user_windows.get(user_id) {\n            let now = Utc::now();\n            let minute_ago = now - Duration::minutes(1);\n            window\n                .timestamps\n                .iter()\n                .filter(|\u0026\u0026ts| ts \u003e= minute_ago)\n                .count()\n        } else {\n            0\n        }\n    }\n\n    /// Clear rate limit window for a user.\n    pub fn clear_user_limits(\u0026mut self, user_id: \u0026str) {\n        self.user_windows.remove(user_id);\n    }\n}\n\nimpl Default for RateLimiter {\n    fn default() -\u003e Self {\n        Self::new(None)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_rate_limit_allows_within_limit() {\n        let config = RateLimitConfig {\n            requests_per_minute: 60,\n            requests_per_hour: 1000,\n            burst_size: 10,\n        };\n        let mut limiter = RateLimiter::new(Some(config));\n\n        // First request should succeed\n        assert!(limiter.check_rate_limit(\"user1\").is_ok());\n\n        // Second request should also succeed (well within limits)\n        assert!(limiter.check_rate_limit(\"user1\").is_ok());\n    }\n\n    #[test]\n    fn test_rate_limit_blocks_per_minute() {\n        let config = RateLimitConfig {\n            requests_per_minute: 3,\n            requests_per_hour: 1000,\n            burst_size: 10,\n        };\n        let mut limiter = RateLimiter::new(Some(config));\n\n        // First 3 requests should succeed\n        for i in 0..3 {\n            assert!(limiter.check_rate_limit(\"user1\").is_ok(), \"Request {} should succeed\", i);\n        }\n\n        // 4th request should fail (exceeds per-minute limit)\n        let result = limiter.check_rate_limit(\"user1\");\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"requests per minute\"));\n    }\n\n    #[test]\n    fn test_rate_limit_blocks_per_hour() {\n        let config = RateLimitConfig {\n            requests_per_minute: 1000, // Set high to not hit minute limit\n            requests_per_hour: 5,\n            burst_size: 1000, // Set high to not hit burst limit\n        };\n        let mut limiter = RateLimiter::new(Some(config));\n\n        // First 5 requests should succeed\n        for i in 0..5 {\n            assert!(limiter.check_rate_limit(\"user1\").is_ok(), \"Request {} should succeed\", i);\n        }\n\n        // 6th request should fail (exceeds per-hour limit)\n        let result = limiter.check_rate_limit(\"user1\");\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"requests per hour\"));\n    }\n\n    #[test]\n    fn test_burst_allows_initial_requests() {\n        let config = RateLimitConfig {\n            requests_per_minute: 100,\n            requests_per_hour: 1000,\n            burst_size: 5,\n        };\n        let mut limiter = RateLimiter::new(Some(config));\n\n        // First 5 requests (burst) should succeed\n        for i in 0..5 {\n            assert!(limiter.check_rate_limit(\"user1\").is_ok(), \"Request {} failed\", i);\n        }\n    }\n\n    #[test]\n    fn test_burst_blocks_after_exhausted() {\n        let config = RateLimitConfig {\n            requests_per_minute: 100,\n            requests_per_hour: 1000,\n            burst_size: 3,\n        };\n        let mut limiter = RateLimiter::new(Some(config));\n\n        // First 3 requests (burst size) should succeed\n        for i in 0..3 {\n            assert!(limiter.check_rate_limit(\"user1\").is_ok(), \"Request {} should succeed\", i);\n        }\n\n        // 4th should fail (burst exhausted)\n        let result = limiter.check_rate_limit(\"user1\");\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"Burst limit exceeded\"));\n    }\n\n    #[test]\n    fn test_per_user_isolation() {\n        let config = RateLimitConfig {\n            requests_per_minute: 2,\n            requests_per_hour: 1000,\n            burst_size: 10,\n        };\n        let mut limiter = RateLimiter::new(Some(config));\n\n        // User1 makes 2 requests (at limit)\n        limiter.check_rate_limit(\"user1\").unwrap();\n        limiter.check_rate_limit(\"user1\").unwrap();\n\n        // User1's 3rd request should fail\n        assert!(limiter.check_rate_limit(\"user1\").is_err());\n\n        // User2's first request should still succeed (separate window)\n        assert!(limiter.check_rate_limit(\"user2\").is_ok());\n    }\n\n    #[test]\n    fn test_get_current_rate() {\n        let config = RateLimitConfig {\n            requests_per_minute: 100,\n            requests_per_hour: 1000,\n            burst_size: 10,\n        };\n        let mut limiter = RateLimiter::new(Some(config));\n\n        // Initially zero\n        assert_eq!(limiter.get_current_rate(\"user1\"), 0);\n\n        // After 3 requests\n        for _ in 0..3 {\n            limiter.check_rate_limit(\"user1\").unwrap();\n        }\n        assert_eq!(limiter.get_current_rate(\"user1\"), 3);\n    }\n\n    #[test]\n    fn test_clear_user_limits() {\n        let config = RateLimitConfig {\n            requests_per_minute: 2,\n            requests_per_hour: 1000,\n            burst_size: 10,\n        };\n        let mut limiter = RateLimiter::new(Some(config));\n\n        // User1 hits limit\n        limiter.check_rate_limit(\"user1\").unwrap();\n        limiter.check_rate_limit(\"user1\").unwrap();\n        assert!(limiter.check_rate_limit(\"user1\").is_err());\n\n        // Clear limits\n        limiter.clear_user_limits(\"user1\");\n\n        // Should succeed again\n        assert!(limiter.check_rate_limit(\"user1\").is_ok());\n    }\n\n    #[test]\n    fn test_multiple_users_independent() {\n        let config = RateLimitConfig {\n            requests_per_minute: 2,\n            requests_per_hour: 1000,\n            burst_size: 10,\n        };\n        let mut limiter = RateLimiter::new(Some(config));\n\n        // User1 uses 2 requests\n        limiter.check_rate_limit(\"user1\").unwrap();\n        limiter.check_rate_limit(\"user1\").unwrap();\n\n        // User2 uses 1 request\n        limiter.check_rate_limit(\"user2\").unwrap();\n\n        // User1 blocked\n        assert!(limiter.check_rate_limit(\"user1\").is_err());\n\n        // User2 still has capacity\n        assert!(limiter.check_rate_limit(\"user2\").is_ok());\n\n        // User3 fresh\n        assert!(limiter.check_rate_limit(\"user3\").is_ok());\n    }\n}\n\n","traces":[{"line":19,"address":[5822544],"length":1,"stats":{"Line":0}},{"line":36,"address":[5822480],"length":1,"stats":{"Line":0}},{"line":44,"address":[5820800],"length":1,"stats":{"Line":1}},{"line":47,"address":[5821081],"length":1,"stats":{"Line":1}},{"line":48,"address":[5821170],"length":1,"stats":{"Line":1}},{"line":56,"address":[5821264],"length":1,"stats":{"Line":1}},{"line":57,"address":[5821442,5821497],"length":1,"stats":{"Line":2}},{"line":68,"address":[5922256],"length":1,"stats":{"Line":1}},{"line":71,"address":[5821714],"length":1,"stats":{"Line":1}},{"line":72,"address":[5821934,5821985],"length":1,"stats":{"Line":1}},{"line":83,"address":[5921968],"length":1,"stats":{"Line":1}},{"line":86,"address":[5822121],"length":1,"stats":{"Line":1}},{"line":87,"address":[5822222,5822318],"length":1,"stats":{"Line":1}},{"line":95,"address":[5822201],"length":1,"stats":{"Line":1}},{"line":109,"address":[5820704],"length":1,"stats":{"Line":0}},{"line":117,"address":[5819872],"length":1,"stats":{"Line":1}},{"line":118,"address":[5819902],"length":1,"stats":{"Line":1}},{"line":121,"address":[5819913],"length":1,"stats":{"Line":1}},{"line":122,"address":[5861376,5861414],"length":1,"stats":{"Line":0}},{"line":124,"address":[5820075],"length":1,"stats":{"Line":1}},{"line":128,"address":[5820112],"length":1,"stats":{"Line":1}},{"line":129,"address":[5820185,5820401],"length":1,"stats":{"Line":2}},{"line":130,"address":[5820199],"length":1,"stats":{"Line":1}},{"line":135,"address":[5861424,5861507,5861429],"length":1,"stats":{"Line":1}},{"line":143,"address":[5820592],"length":1,"stats":{"Line":0}}],"covered":20,"coverable":25},{"path":["/","home","user","jeeves-core","src","kernel","resources.rs"],"content":"//! Resource tracking and quota enforcement.\n//!\n//! Tracks resource usage across processes and enforces quotas.\n\nuse std::collections::HashMap;\n\nuse super::types::{ProcessControlBlock, ResourceUsage};\nuse crate::types::{Error, Result};\n\n/// Resource tracker - tracks usage across all processes.\n///\n/// NOT a separate actor - owned by Kernel and called via \u0026mut self.\n#[derive(Debug, Default)]\npub struct ResourceTracker {\n    /// Per-user usage aggregation (optional, for multi-tenant quotas)\n    user_usage: HashMap\u003cString, ResourceUsage\u003e,\n}\n\nimpl ResourceTracker {\n    pub fn new() -\u003e Self {\n        Self {\n            user_usage: HashMap::new(),\n        }\n    }\n\n    /// Check if process quota is exceeded.\n    pub fn check_quota(\u0026self, pcb: \u0026ProcessControlBlock) -\u003e Result\u003c()\u003e {\n        if let Some(reason) = pcb.check_quota() {\n            return Err(Error::quota_exceeded(format!(\n                \"Process {} quota exceeded: {}\",\n                pcb.pid, reason\n            )));\n        }\n        Ok(())\n    }\n\n    /// Record resource usage for a process.\n    pub fn record_usage(\n        \u0026mut self,\n        user_id: \u0026str,\n        llm_calls: i32,\n        tool_calls: i32,\n        tokens_in: i64,\n        tokens_out: i64,\n    ) {\n        let user_usage = self.user_usage.entry(user_id.to_string()).or_default();\n        user_usage.llm_calls += llm_calls;\n        user_usage.tool_calls += tool_calls;\n        user_usage.tokens_in += tokens_in;\n        user_usage.tokens_out += tokens_out;\n    }\n\n    /// Get usage for a user.\n    pub fn get_user_usage(\u0026self, user_id: \u0026str) -\u003e Option\u003c\u0026ResourceUsage\u003e {\n        self.user_usage.get(user_id)\n    }\n\n    /// Clear usage for a user (e.g., on quota reset).\n    pub fn clear_user_usage(\u0026mut self, user_id: \u0026str) {\n        self.user_usage.remove(user_id);\n    }\n\n    /// Get total usage across all users.\n    pub fn total_usage(\u0026self) -\u003e ResourceUsage {\n        let mut total = ResourceUsage::default();\n        for usage in self.user_usage.values() {\n            total.llm_calls += usage.llm_calls;\n            total.tool_calls += usage.tool_calls;\n            total.agent_hops += usage.agent_hops;\n            total.iterations += usage.iterations;\n            total.tokens_in += usage.tokens_in;\n            total.tokens_out += usage.tokens_out;\n            total.inference_requests += usage.inference_requests;\n            total.inference_input_chars += usage.inference_input_chars;\n        }\n        total\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::kernel::types::{ProcessControlBlock, ProcessState, ResourceQuota};\n\n    #[test]\n    fn test_record_usage() {\n        let mut tracker = ResourceTracker::new();\n        tracker.record_usage(\"user1\", 5, 10, 1000, 500);\n\n        let usage = tracker.get_user_usage(\"user1\").unwrap();\n        assert_eq!(usage.llm_calls, 5);\n        assert_eq!(usage.tool_calls, 10);\n        assert_eq!(usage.tokens_in, 1000);\n        assert_eq!(usage.tokens_out, 500);\n    }\n\n    #[test]\n    fn test_check_quota_within_bounds() {\n        let tracker = ResourceTracker::new();\n\n        let mut pcb = ProcessControlBlock::new(\n            \"env1\".to_string(),\n            \"req1\".to_string(),\n            \"user1\".to_string(),\n            \"sess1\".to_string(),\n        );\n        pcb.state = ProcessState::Running;\n        pcb.quota = ResourceQuota {\n            max_llm_calls: 10,\n            max_input_tokens: 10000,\n            max_output_tokens: 5000,\n            max_agent_hops: 5,\n            max_iterations: 100,\n            timeout_seconds: 300,\n            ..ResourceQuota::default()\n        };\n        pcb.usage = ResourceUsage {\n            llm_calls: 5,\n            tokens_in: 5000,\n            tokens_out: 2000,\n            agent_hops: 2,\n            iterations: 10,\n            ..Default::default()\n        };\n\n        assert!(tracker.check_quota(\u0026pcb).is_ok());\n    }\n\n    #[test]\n    fn test_check_quota_exceeded_llm_calls() {\n        let tracker = ResourceTracker::new();\n\n        let mut pcb = ProcessControlBlock::new(\n            \"env1\".to_string(),\n            \"req1\".to_string(),\n            \"user1\".to_string(),\n            \"sess1\".to_string(),\n        );\n        pcb.state = ProcessState::Running;\n        pcb.quota = ResourceQuota {\n            max_llm_calls: 10,\n            max_input_tokens: 10000,\n            max_output_tokens: 5000,\n            max_agent_hops: 5,\n            max_iterations: 100,\n            timeout_seconds: 300,\n            ..ResourceQuota::default()\n        };\n        pcb.usage = ResourceUsage {\n            llm_calls: 15, // Exceeds max_llm_calls\n            tokens_in: 5000,\n            tokens_out: 2000,\n            agent_hops: 2,\n            iterations: 10,\n            ..Default::default()\n        };\n\n        let result = tracker.check_quota(\u0026pcb);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"quota exceeded\"));\n    }\n\n    #[test]\n    fn test_check_quota_exceeded_tokens() {\n        let tracker = ResourceTracker::new();\n\n        let mut pcb = ProcessControlBlock::new(\n            \"env1\".to_string(),\n            \"req1\".to_string(),\n            \"user1\".to_string(),\n            \"sess1\".to_string(),\n        );\n        pcb.state = ProcessState::Running;\n        pcb.quota = ResourceQuota {\n            max_llm_calls: 10,\n            max_input_tokens: 10000,\n            max_output_tokens: 5000,\n            max_agent_hops: 5,\n            max_iterations: 100,\n            timeout_seconds: 300,\n            ..ResourceQuota::default()\n        };\n        pcb.usage = ResourceUsage {\n            llm_calls: 5,\n            tokens_in: 15000, // Exceeds max_input_tokens\n            tokens_out: 2000,\n            agent_hops: 2,\n            iterations: 10,\n            ..Default::default()\n        };\n\n        let result = tracker.check_quota(\u0026pcb);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"quota exceeded\"));\n    }\n\n    #[test]\n    fn test_check_quota_exceeded_agent_hops() {\n        let tracker = ResourceTracker::new();\n\n        let mut pcb = ProcessControlBlock::new(\n            \"env1\".to_string(),\n            \"req1\".to_string(),\n            \"user1\".to_string(),\n            \"sess1\".to_string(),\n        );\n        pcb.state = ProcessState::Running;\n        pcb.quota = ResourceQuota {\n            max_llm_calls: 10,\n            max_input_tokens: 10000,\n            max_output_tokens: 5000,\n            max_agent_hops: 5,\n            max_iterations: 100,\n            timeout_seconds: 300,\n            ..ResourceQuota::default()\n        };\n        pcb.usage = ResourceUsage {\n            llm_calls: 5,\n            tokens_in: 5000,\n            tokens_out: 2000,\n            agent_hops: 10, // Exceeds max_agent_hops\n            iterations: 10,\n            ..Default::default()\n        };\n\n        let result = tracker.check_quota(\u0026pcb);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"quota exceeded\"));\n    }\n\n    #[test]\n    fn test_per_user_aggregation() {\n        let mut tracker = ResourceTracker::new();\n\n        // Record usage for user1\n        tracker.record_usage(\"user1\", 5, 10, 1000, 500);\n        tracker.record_usage(\"user1\", 3, 5, 500, 250);\n\n        // Record usage for user2\n        tracker.record_usage(\"user2\", 2, 4, 300, 150);\n\n        let user1_usage = tracker.get_user_usage(\"user1\").unwrap();\n        assert_eq!(user1_usage.llm_calls, 8);\n        assert_eq!(user1_usage.tool_calls, 15);\n        assert_eq!(user1_usage.tokens_in, 1500);\n        assert_eq!(user1_usage.tokens_out, 750);\n\n        let user2_usage = tracker.get_user_usage(\"user2\").unwrap();\n        assert_eq!(user2_usage.llm_calls, 2);\n        assert_eq!(user2_usage.tool_calls, 4);\n        assert_eq!(user2_usage.tokens_in, 300);\n        assert_eq!(user2_usage.tokens_out, 150);\n    }\n\n    #[test]\n    fn test_system_usage_totals() {\n        let mut tracker = ResourceTracker::new();\n\n        tracker.record_usage(\"user1\", 5, 10, 1000, 500);\n        tracker.record_usage(\"user2\", 3, 6, 600, 300);\n        tracker.record_usage(\"user3\", 2, 4, 400, 200);\n\n        let total = tracker.total_usage();\n        assert_eq!(total.llm_calls, 10);\n        assert_eq!(total.tool_calls, 20);\n        assert_eq!(total.tokens_in, 2000);\n        assert_eq!(total.tokens_out, 1000);\n    }\n\n    #[test]\n    fn test_clear_user_usage() {\n        let mut tracker = ResourceTracker::new();\n\n        tracker.record_usage(\"user1\", 5, 10, 1000, 500);\n        assert!(tracker.get_user_usage(\"user1\").is_some());\n\n        tracker.clear_user_usage(\"user1\");\n        assert!(tracker.get_user_usage(\"user1\").is_none());\n\n        // Total should be zero after clearing only user\n        let total = tracker.total_usage();\n        assert_eq!(total.llm_calls, 0);\n    }\n}\n\n","traces":[{"line":20,"address":[5819808],"length":1,"stats":{"Line":0}},{"line":27,"address":[5818256,5818658],"length":1,"stats":{"Line":1}},{"line":28,"address":[5818319,5818300],"length":1,"stats":{"Line":2}},{"line":29,"address":[5818526,5818488,5818343],"length":1,"stats":{"Line":3}},{"line":34,"address":[5818307],"length":1,"stats":{"Line":1}},{"line":38,"address":[5819424],"length":1,"stats":{"Line":1}},{"line":46,"address":[5819516,5819453],"length":1,"stats":{"Line":2}},{"line":47,"address":[5819582,5819641],"length":1,"stats":{"Line":1}},{"line":48,"address":[5819592,5819654],"length":1,"stats":{"Line":1}},{"line":49,"address":[5819600,5819667],"length":1,"stats":{"Line":1}},{"line":50,"address":[5819618,5819680],"length":1,"stats":{"Line":1}},{"line":59,"address":[5819776],"length":1,"stats":{"Line":0}},{"line":64,"address":[5818672],"length":1,"stats":{"Line":1}},{"line":66,"address":[5818853],"length":1,"stats":{"Line":1}},{"line":67,"address":[5819331,5819057,5819269,5819195,5819241,5819149,5819103,5818879,5819376,5819010],"length":1,"stats":{"Line":2}},{"line":68,"address":[5819107,5819014,5819290,5819380,5819199,5819245,5819314,5819153,5818892,5819335,5819061],"length":1,"stats":{"Line":2}},{"line":69,"address":[5818905,5819111,5819018,5819339,5819157,5819384,5819249,5819359,5819065,5819294,5819203],"length":1,"stats":{"Line":2}},{"line":70,"address":[5819342,5819021,5819252,5819297,5819405,5819069,5819115,5819388,5819161,5819207,5818917],"length":1,"stats":{"Line":2}},{"line":71,"address":[5819083,5819311,5819175,5819356,5819129,5819035,5819221,5819266,5818928,5819402],"length":1,"stats":{"Line":2}},{"line":72,"address":[5819072,5819391,5819300,5819118,5819132,5819164,5819210,5819024,5819255,5819345,5818937],"length":1,"stats":{"Line":2}},{"line":73,"address":[5819349,5819304,5819076,5819122,5819259,5819178,5819214,5818949,5819028,5819168,5819395],"length":1,"stats":{"Line":2}},{"line":74,"address":[5819398,5819224,5819171,5819262,5819031,5819125,5819217,5819307,5818961,5819352,5819079],"length":1,"stats":{"Line":2}}],"covered":20,"coverable":22},{"path":["/","home","user","jeeves-core","src","kernel","services.rs"],"content":"//! Service registry - IPC coordinator and service discovery.\n//!\n//! Features:\n//!   - Service registration and discovery\n//!   - Health tracking\n//!   - Load balancing\n//!   - Dispatch routing\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\nuse crate::kernel::SchedulingPriority;\n\n// =============================================================================\n// Service Status\n// =============================================================================\n\n/// Health status of a service.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum ServiceStatus {\n    /// Service is healthy and accepting requests\n    Healthy,\n    /// Service is running but with reduced capacity\n    Degraded,\n    /// Service is not accepting requests\n    Unhealthy,\n    /// Service status is unknown\n    Unknown,\n}\n\n// =============================================================================\n// Service Types\n// =============================================================================\n\n/// Service type constants for classifying services.\npub const SERVICE_TYPE_FLOW: \u0026str = \"flow\";\npub const SERVICE_TYPE_WORKER: \u0026str = \"worker\";\npub const SERVICE_TYPE_VERTICAL: \u0026str = \"vertical\";\npub const SERVICE_TYPE_INFERENCE: \u0026str = \"inference\";\n\n// =============================================================================\n// Service Info\n// =============================================================================\n\n/// ServiceInfo describes a registered service.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ServiceInfo {\n    // Identity\n    pub name: String,\n    pub service_type: String, // \"flow\", \"worker\", \"vertical\", \"inference\"\n    pub version: String,\n\n    // Capabilities\n    pub capabilities: Vec\u003cString\u003e,\n\n    // Capacity\n    pub max_concurrent: i32,\n    pub current_load: i32,\n\n    // Health\n    pub status: ServiceStatus,\n    pub last_health_check: DateTime\u003cUtc\u003e,\n\n    // Metadata\n    #[serde(skip_serializing_if = \"HashMap::is_empty\")]\n    pub metadata: HashMap\u003cString, serde_json::Value\u003e,\n}\n\nimpl ServiceInfo {\n    /// Create a new service descriptor.\n    pub fn new(name: String, service_type: String) -\u003e Self {\n        Self {\n            name,\n            service_type,\n            version: \"1.0.0\".to_string(),\n            capabilities: Vec::new(),\n            max_concurrent: 10,\n            current_load: 0,\n            status: ServiceStatus::Healthy,\n            last_health_check: Utc::now(),\n            metadata: HashMap::new(),\n        }\n    }\n\n    /// Check if the service can accept more load.\n    pub fn can_accept(\u0026self) -\u003e bool {\n        self.status == ServiceStatus::Healthy \u0026\u0026 self.current_load \u003c self.max_concurrent\n    }\n\n    /// Check if the service is healthy.\n    pub fn is_healthy(\u0026self) -\u003e bool {\n        matches!(self.status, ServiceStatus::Healthy | ServiceStatus::Degraded)\n    }\n}\n\n// =============================================================================\n// Dispatch Target\n// =============================================================================\n\n/// DispatchTarget represents a target for request dispatch.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DispatchTarget {\n    pub service_name: String,\n    pub method: String,\n    pub priority: SchedulingPriority,\n    pub timeout_seconds: i32,\n    pub retry_count: i32,\n    pub max_retries: i32,\n}\n\nimpl DispatchTarget {\n    /// Check if the dispatch can be retried.\n    pub fn can_retry(\u0026self) -\u003e bool {\n        self.retry_count \u003c self.max_retries\n    }\n\n    /// Increment the retry count.\n    pub fn increment_retry(\u0026mut self) {\n        self.retry_count += 1;\n    }\n}\n\n// =============================================================================\n// Dispatch Result\n// =============================================================================\n\n/// DispatchResult represents the result of a dispatch operation.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DispatchResult {\n    pub success: bool,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub error: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"HashMap::is_empty\")]\n    pub data: HashMap\u003cString, serde_json::Value\u003e,\n    pub duration_ms: i64,\n    pub retries: i32,\n}\n\n// =============================================================================\n// Service Handler\n// =============================================================================\n\n/// ServiceHandler is a function that handles service requests.\npub type ServiceHandler = Arc\u003c\n    dyn Fn(\u0026DispatchTarget, \u0026HashMap\u003cString, serde_json::Value\u003e) -\u003e Result\u003cDispatchResult, String\u003e\n        + Send\n        + Sync,\n\u003e;\n\n// =============================================================================\n// Service Registry\n// =============================================================================\n\n/// ServiceRegistry manages service registration, discovery, and dispatch.\n///\n/// Single-actor implementation for tracking registered services.\n#[derive(Debug)]\npub struct ServiceRegistry {\n    /// Service registry\n    services: HashMap\u003cString, ServiceInfo\u003e,\n    /// Dispatch handlers (using type erasure for simplicity)\n    handlers: HashMap\u003cString, usize\u003e, // Placeholder - real impl would use ServiceHandler\n}\n\nimpl ServiceRegistry {\n    /// Create a new service registry.\n    pub fn new() -\u003e Self {\n        Self {\n            services: HashMap::new(),\n            handlers: HashMap::new(),\n        }\n    }\n\n    // =============================================================================\n    // Service Registration\n    // =============================================================================\n\n    /// Register a service with the registry.\n    /// Returns true if registration succeeded, false if service already exists.\n    pub fn register_service(\u0026mut self, info: ServiceInfo) -\u003e bool {\n        if self.services.contains_key(\u0026info.name) {\n            return false;\n        }\n\n        self.services.insert(info.name.clone(), info);\n        true\n    }\n\n    /// Unregister a service.\n    /// Returns true if unregistration succeeded.\n    pub fn unregister_service(\u0026mut self, service_name: \u0026str) -\u003e bool {\n        if !self.services.contains_key(service_name) {\n            return false;\n        }\n\n        self.services.remove(service_name);\n        self.handlers.remove(service_name);\n        true\n    }\n\n    /// Register a handler for a service (placeholder).\n    /// Full implementation would store Arc\u003cdyn Fn\u003e but simplified for now.\n    pub fn register_handler(\u0026mut self, service_name: String) {\n        // Placeholder - just mark that handler exists\n        self.handlers.insert(service_name, 1);\n    }\n\n    // =============================================================================\n    // Service Discovery\n    // =============================================================================\n\n    /// Get a service by name.\n    pub fn get_service(\u0026self, service_name: \u0026str) -\u003e Option\u003cServiceInfo\u003e {\n        self.services.get(service_name).cloned()\n    }\n\n    /// List all registered services matching criteria.\n    pub fn list_services(\u0026self, service_type: Option\u003c\u0026str\u003e, healthy_only: bool) -\u003e Vec\u003cServiceInfo\u003e {\n        self.services\n            .values()\n            .filter(|svc| {\n                if let Some(stype) = service_type {\n                    if svc.service_type != stype {\n                        return false;\n                    }\n                }\n                if healthy_only \u0026\u0026 !svc.is_healthy() {\n                    return false;\n                }\n                true\n            })\n            .cloned()\n            .collect()\n    }\n\n    /// Get all service names.\n    pub fn get_service_names(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.services.keys().cloned().collect()\n    }\n\n    /// Check if a service is registered.\n    pub fn has_service(\u0026self, service_name: \u0026str) -\u003e bool {\n        self.services.contains_key(service_name)\n    }\n\n    /// Check if a service has a handler registered.\n    pub fn has_handler(\u0026self, service_name: \u0026str) -\u003e bool {\n        self.handlers.contains_key(service_name)\n    }\n\n    // =============================================================================\n    // Load Management\n    // =============================================================================\n\n    /// Increment load for a service.\n    pub fn increment_load(\u0026mut self, service_name: \u0026str) -\u003e bool {\n        if let Some(service) = self.services.get_mut(service_name) {\n            service.current_load += 1;\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Decrement load for a service.\n    pub fn decrement_load(\u0026mut self, service_name: \u0026str) -\u003e bool {\n        if let Some(service) = self.services.get_mut(service_name) {\n            service.current_load = (service.current_load - 1).max(0);\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Get current load for a service.\n    pub fn get_load(\u0026self, service_name: \u0026str) -\u003e i32 {\n        self.services\n            .get(service_name)\n            .map(|s| s.current_load)\n            .unwrap_or(0)\n    }\n\n    // =============================================================================\n    // Health Management\n    // =============================================================================\n\n    /// Update health status for a service.\n    pub fn update_health(\u0026mut self, service_name: \u0026str, status: ServiceStatus) -\u003e bool {\n        if let Some(service) = self.services.get_mut(service_name) {\n            service.status = status;\n            service.last_health_check = Utc::now();\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Get count of healthy services.\n    pub fn get_healthy_count(\u0026self) -\u003e usize {\n        self.services\n            .values()\n            .filter(|s| s.is_healthy())\n            .count()\n    }\n\n    // =============================================================================\n    // Statistics\n    // =============================================================================\n\n    /// Get statistics for a specific service.\n    pub fn get_service_stats(\u0026self, service_name: \u0026str) -\u003e Option\u003cServiceStats\u003e {\n        self.services.get(service_name).map(|svc| ServiceStats {\n            name: svc.name.clone(),\n            service_type: svc.service_type.clone(),\n            status: svc.status,\n            current_load: svc.current_load,\n            max_concurrent: svc.max_concurrent,\n            utilization: if svc.max_concurrent \u003e 0 {\n                (svc.current_load as f64 / svc.max_concurrent as f64) * 100.0\n            } else {\n                0.0\n            },\n        })\n    }\n\n    /// Get overall registry statistics.\n    pub fn get_stats(\u0026self) -\u003e RegistryStats {\n        let mut stats = RegistryStats {\n            total_services: self.services.len(),\n            healthy_services: 0,\n            degraded_services: 0,\n            unhealthy_services: 0,\n            total_load: 0,\n            total_capacity: 0,\n            services_by_type: HashMap::new(),\n        };\n\n        for svc in self.services.values() {\n            match svc.status {\n                ServiceStatus::Healthy =\u003e stats.healthy_services += 1,\n                ServiceStatus::Degraded =\u003e stats.degraded_services += 1,\n                ServiceStatus::Unhealthy =\u003e stats.unhealthy_services += 1,\n                ServiceStatus::Unknown =\u003e {}\n            }\n\n            stats.total_load += svc.current_load as usize;\n            stats.total_capacity += svc.max_concurrent as usize;\n\n            *stats\n                .services_by_type\n                .entry(svc.service_type.clone())\n                .or_insert(0) += 1;\n        }\n\n        stats\n    }\n\n    // =============================================================================\n    // Dispatch (Placeholder)\n    // =============================================================================\n\n    /// Dispatch a request to a service (placeholder implementation).\n    /// Full implementation would invoke the registered handler.\n    pub fn dispatch(\n        \u0026mut self,\n        target: \u0026DispatchTarget,\n        _data: \u0026HashMap\u003cString, serde_json::Value\u003e,\n    ) -\u003e Result\u003cDispatchResult, String\u003e {\n        // Check if service exists and has handler\n        if !self.has_service(\u0026target.service_name) {\n            return Err(format!(\"Service not found: {}\", target.service_name));\n        }\n\n        if !self.has_handler(\u0026target.service_name) {\n            return Err(format!(\"No handler for service: {}\", target.service_name));\n        }\n\n        // Check if service can accept load\n        if let Some(svc) = self.services.get(\u0026target.service_name) {\n            if !svc.can_accept() {\n                return Err(format!(\n                    \"Service {} cannot accept more load (current: {}, max: {})\",\n                    target.service_name, svc.current_load, svc.max_concurrent\n                ));\n            }\n        }\n\n        // Placeholder result\n        // Full implementation would:\n        // 1. Increment load\n        // 2. Invoke handler\n        // 3. Decrement load\n        // 4. Return result\n        Ok(DispatchResult {\n            success: true,\n            error: None,\n            data: HashMap::new(),\n            duration_ms: 0,\n            retries: target.retry_count,\n        })\n    }\n}\n\nimpl Default for ServiceRegistry {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n// =============================================================================\n// Statistics Types\n// =============================================================================\n\n/// Statistics for a specific service.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ServiceStats {\n    pub name: String,\n    pub service_type: String,\n    pub status: ServiceStatus,\n    pub current_load: i32,\n    pub max_concurrent: i32,\n    pub utilization: f64, // Percentage\n}\n\n/// Overall registry statistics.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RegistryStats {\n    pub total_services: usize,\n    pub healthy_services: usize,\n    pub degraded_services: usize,\n    pub unhealthy_services: usize,\n    pub total_load: usize,\n    pub total_capacity: usize,\n    pub services_by_type: HashMap\u003cString, usize\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","jeeves-core","src","kernel","types.rs"],"content":"//! Kernel types: ProcessState, ProcessControlBlock, Resource tracking.\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\nuse crate::envelope::InterruptKind;\n\n/// Process lifecycle state (Unix-like).\n///\n/// State transitions:\n/// ```text\n/// NEW → READY → RUNNING → {WAITING | BLOCKED | TERMINATED}\n///                    ↓         ↓\n///                  READY     ZOMBIE\n/// ```\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Hash)]\n#[serde(rename_all = \"lowercase\")]\npub enum ProcessState {\n    New,\n    Ready,\n    Running,\n    Waiting,\n    Blocked,\n    Terminated,\n    Zombie,\n}\n\nimpl ProcessState {\n    /// Check if this is a terminal state.\n    pub fn is_terminal(self) -\u003e bool {\n        matches!(self, ProcessState::Terminated | ProcessState::Zombie)\n    }\n\n    /// Check if process can be scheduled.\n    pub fn can_schedule(self) -\u003e bool {\n        matches!(self, ProcessState::New | ProcessState::Ready)\n    }\n\n    /// Check if process is runnable.\n    pub fn is_runnable(self) -\u003e bool {\n        self == ProcessState::Ready\n    }\n\n    /// Check if transition is valid.\n    pub fn can_transition_to(self, to: ProcessState) -\u003e bool {\n        match (self, to) {\n            // NEW\n            (ProcessState::New, ProcessState::Ready) =\u003e true,\n            (ProcessState::New, ProcessState::Terminated) =\u003e true,\n            // READY\n            (ProcessState::Ready, ProcessState::Running) =\u003e true,\n            (ProcessState::Ready, ProcessState::Terminated) =\u003e true,\n            // RUNNING\n            (ProcessState::Running, ProcessState::Ready) =\u003e true, // Preempted\n            (ProcessState::Running, ProcessState::Waiting) =\u003e true, // I/O\n            (ProcessState::Running, ProcessState::Blocked) =\u003e true, // Resource exhausted\n            (ProcessState::Running, ProcessState::Terminated) =\u003e true,\n            // WAITING\n            (ProcessState::Waiting, ProcessState::Ready) =\u003e true,\n            (ProcessState::Waiting, ProcessState::Terminated) =\u003e true,\n            // BLOCKED\n            (ProcessState::Blocked, ProcessState::Ready) =\u003e true,\n            (ProcessState::Blocked, ProcessState::Terminated) =\u003e true,\n            // TERMINATED\n            (ProcessState::Terminated, ProcessState::Zombie) =\u003e true,\n            // ZOMBIE is terminal\n            (ProcessState::Zombie, _) =\u003e false,\n            // All other transitions invalid\n            _ =\u003e false,\n        }\n    }\n}\n\n/// Scheduling priority.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Hash)]\n#[serde(rename_all = \"lowercase\")]\npub enum SchedulingPriority {\n    Realtime,\n    High,\n    Normal,\n    Low,\n    Idle,\n}\n\nimpl SchedulingPriority {\n    /// Get heap priority value (lower = higher priority).\n    pub fn to_heap_value(self) -\u003e i32 {\n        match self {\n            SchedulingPriority::Realtime =\u003e 0,\n            SchedulingPriority::High =\u003e 1,\n            SchedulingPriority::Normal =\u003e 2,\n            SchedulingPriority::Low =\u003e 3,\n            SchedulingPriority::Idle =\u003e 4,\n        }\n    }\n}\n\nimpl Default for SchedulingPriority {\n    fn default() -\u003e Self {\n        SchedulingPriority::Normal\n    }\n}\n\n/// Resource quota (cgroup-style limits).\n/// Matches proto ResourceQuota exactly.\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct ResourceQuota {\n    pub max_input_tokens: i32,\n    pub max_output_tokens: i32,\n    pub max_context_tokens: i32,\n    pub max_llm_calls: i32,\n    pub max_tool_calls: i32,\n    pub max_agent_hops: i32,\n    pub max_iterations: i32,\n    pub timeout_seconds: i32,\n    pub soft_timeout_seconds: i32,\n    pub rate_limit_rpm: i32,\n    pub rate_limit_rph: i32,\n    pub rate_limit_burst: i32,\n    pub max_inference_requests: i32,\n    pub max_inference_input_chars: i32,\n}\n\nimpl ResourceQuota {\n    pub fn default_quota() -\u003e Self {\n        Self {\n            max_input_tokens: 100_000,\n            max_output_tokens: 50_000,\n            max_context_tokens: 150_000,\n            max_llm_calls: 100,\n            max_tool_calls: 50,\n            max_agent_hops: 10,\n            max_iterations: 20,\n            timeout_seconds: 300,\n            soft_timeout_seconds: 240,\n            rate_limit_rpm: 60,\n            rate_limit_rph: 1000,\n            rate_limit_burst: 10,\n            max_inference_requests: 50,\n            max_inference_input_chars: 500_000,\n        }\n    }\n}\n\nimpl Default for ResourceQuota {\n    fn default() -\u003e Self {\n        Self::default_quota()\n    }\n}\n\n/// Resource usage tracking.\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Default)]\npub struct ResourceUsage {\n    pub llm_calls: i32,\n    pub tool_calls: i32,\n    pub agent_hops: i32,\n    pub iterations: i32,\n    pub tokens_in: i64,\n    pub tokens_out: i64,\n    pub elapsed_seconds: f64,\n    pub inference_requests: i32,\n    pub inference_input_chars: i64,\n}\n\nimpl ResourceUsage {\n    /// Check if any quota is exceeded.\n    pub fn exceeds_quota(\u0026self, quota: \u0026ResourceQuota) -\u003e Option\u003cString\u003e {\n        if self.llm_calls \u003e quota.max_llm_calls {\n            return Some(format!(\n                \"llm_calls {} \u003e {}\",\n                self.llm_calls, quota.max_llm_calls\n            ));\n        }\n        if self.tool_calls \u003e quota.max_tool_calls {\n            return Some(format!(\n                \"tool_calls {} \u003e {}\",\n                self.tool_calls, quota.max_tool_calls\n            ));\n        }\n        if self.agent_hops \u003e quota.max_agent_hops {\n            return Some(format!(\n                \"agent_hops {} \u003e {}\",\n                self.agent_hops, quota.max_agent_hops\n            ));\n        }\n        if self.iterations \u003e quota.max_iterations {\n            return Some(format!(\n                \"iterations {} \u003e {}\",\n                self.iterations, quota.max_iterations\n            ));\n        }\n        if self.tokens_in \u003e quota.max_input_tokens as i64 {\n            return Some(format!(\n                \"tokens_in {} \u003e {}\",\n                self.tokens_in, quota.max_input_tokens\n            ));\n        }\n        if self.tokens_out \u003e quota.max_output_tokens as i64 {\n            return Some(format!(\n                \"tokens_out {} \u003e {}\",\n                self.tokens_out, quota.max_output_tokens\n            ));\n        }\n        if self.elapsed_seconds \u003e quota.timeout_seconds as f64 {\n            return Some(format!(\n                \"elapsed_seconds {} \u003e {}\",\n                self.elapsed_seconds, quota.timeout_seconds\n            ));\n        }\n        if self.inference_requests \u003e quota.max_inference_requests {\n            return Some(format!(\n                \"inference_requests {} \u003e {}\",\n                self.inference_requests, quota.max_inference_requests\n            ));\n        }\n        if self.inference_input_chars \u003e quota.max_inference_input_chars as i64 {\n            return Some(format!(\n                \"inference_input_chars {} \u003e {}\",\n                self.inference_input_chars, quota.max_inference_input_chars\n            ));\n        }\n        None\n    }\n}\n\n/// Process Control Block - kernel's metadata about a running process.\n///\n/// The actual request state is in Envelope; this tracks:\n/// - Scheduling state\n/// - Resource accounting\n/// - Interrupt status\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct ProcessControlBlock {\n    // Identity\n    pub pid: String,\n    pub request_id: String,\n    pub user_id: String,\n    pub session_id: String,\n\n    // State\n    pub state: ProcessState,\n    pub priority: SchedulingPriority,\n\n    // Resource tracking\n    pub quota: ResourceQuota,\n    pub usage: ResourceUsage,\n\n    // Scheduling timestamps\n    pub created_at: DateTime\u003cUtc\u003e,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub started_at: Option\u003cDateTime\u003cUtc\u003e\u003e,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub completed_at: Option\u003cDateTime\u003cUtc\u003e\u003e,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub last_scheduled_at: Option\u003cDateTime\u003cUtc\u003e\u003e,\n\n    // Current execution\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub current_stage: Option\u003cString\u003e,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub current_service: Option\u003cString\u003e,\n\n    // Interrupt handling\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub pending_interrupt: Option\u003cInterruptKind\u003e,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub interrupt_data: Option\u003cHashMap\u003cString, serde_json::Value\u003e\u003e,\n\n    // Parent/child relationships\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub parent_pid: Option\u003cString\u003e,\n\n    pub child_pids: Vec\u003cString\u003e,\n}\n\nimpl ProcessControlBlock {\n    pub fn new(pid: String, request_id: String, user_id: String, session_id: String) -\u003e Self {\n        Self {\n            pid,\n            request_id,\n            user_id,\n            session_id,\n            state: ProcessState::New,\n            priority: SchedulingPriority::default(),\n            quota: ResourceQuota::default(),\n            usage: ResourceUsage::default(),\n            created_at: Utc::now(),\n            started_at: None,\n            completed_at: None,\n            last_scheduled_at: None,\n            current_stage: None,\n            current_service: None,\n            pending_interrupt: None,\n            interrupt_data: None,\n            parent_pid: None,\n            child_pids: Vec::new(),\n        }\n    }\n\n    /// Transition to RUNNING state.\n    pub fn start(\u0026mut self) {\n        let now = Utc::now();\n        self.state = ProcessState::Running;\n        self.started_at = Some(now);\n        self.last_scheduled_at = Some(now);\n    }\n\n    /// Transition to TERMINATED state.\n    pub fn complete(\u0026mut self) {\n        let now = Utc::now();\n        self.state = ProcessState::Terminated;\n        self.completed_at = Some(now);\n        if let Some(started) = self.started_at {\n            self.usage.elapsed_seconds = (now - started).num_milliseconds() as f64 / 1000.0;\n        }\n    }\n\n    /// Transition to BLOCKED state.\n    pub fn block(\u0026mut self, reason: String) {\n        self.state = ProcessState::Blocked;\n        if self.interrupt_data.is_none() {\n            self.interrupt_data = Some(HashMap::new());\n        }\n        if let Some(ref mut data) = self.interrupt_data {\n            data.insert(\n                \"block_reason\".to_string(),\n                serde_json::Value::String(reason),\n            );\n        }\n    }\n\n    /// Transition to WAITING state.\n    pub fn wait(\u0026mut self, interrupt_kind: InterruptKind) {\n        self.state = ProcessState::Waiting;\n        self.pending_interrupt = Some(interrupt_kind);\n    }\n\n    /// Resume from WAITING/BLOCKED to READY.\n    pub fn resume(\u0026mut self) {\n        if matches!(self.state, ProcessState::Waiting | ProcessState::Blocked) {\n            self.state = ProcessState::Ready;\n            self.pending_interrupt = None;\n        }\n    }\n\n    /// Check if any quota exceeded.\n    pub fn check_quota(\u0026self) -\u003e Option\u003cString\u003e {\n        self.usage.exceeds_quota(\u0026self.quota)\n    }\n\n    /// Check if process can be scheduled.\n    pub fn can_schedule(\u0026self) -\u003e bool {\n        self.state.can_schedule()\n    }\n\n    /// Check if process is runnable.\n    pub fn is_runnable(\u0026self) -\u003e bool {\n        self.state.is_runnable()\n    }\n\n    /// Check if process terminated.\n    pub fn is_terminated(\u0026self) -\u003e bool {\n        self.state.is_terminal()\n    }\n}\n","traces":[{"line":32,"address":[5842032],"length":1,"stats":{"Line":1}},{"line":47,"address":[5842048,5842086,5842105],"length":1,"stats":{"Line":0}},{"line":89,"address":[5843024],"length":1,"stats":{"Line":0}},{"line":147,"address":[5844784],"length":1,"stats":{"Line":0}},{"line":168,"address":[5842128],"length":1,"stats":{"Line":1}},{"line":169,"address":[5842145],"length":1,"stats":{"Line":1}},{"line":170,"address":[5842306,5842161],"length":1,"stats":{"Line":1}},{"line":175,"address":[5842239],"length":1,"stats":{"Line":1}},{"line":176,"address":[5842256],"length":1,"stats":{"Line":0}},{"line":181,"address":[5842368],"length":1,"stats":{"Line":1}},{"line":182,"address":[5842385],"length":1,"stats":{"Line":1}},{"line":187,"address":[5842432],"length":1,"stats":{"Line":1}},{"line":188,"address":[5842449],"length":1,"stats":{"Line":0}},{"line":193,"address":[5842550],"length":1,"stats":{"Line":1}},{"line":194,"address":[5842563,5842634],"length":1,"stats":{"Line":1}},{"line":199,"address":[5842656],"length":1,"stats":{"Line":1}},{"line":200,"address":[5842679],"length":1,"stats":{"Line":0}},{"line":205,"address":[5842720],"length":1,"stats":{"Line":1}},{"line":206,"address":[5842750],"length":1,"stats":{"Line":0}},{"line":211,"address":[5842808],"length":1,"stats":{"Line":1}},{"line":212,"address":[5842825],"length":1,"stats":{"Line":0}},{"line":217,"address":[5842881],"length":1,"stats":{"Line":1}},{"line":218,"address":[5842904],"length":1,"stats":{"Line":0}},{"line":223,"address":[5842976],"length":1,"stats":{"Line":1}},{"line":283,"address":[5843072,5843779],"length":1,"stats":{"Line":1}},{"line":293,"address":[5843196],"length":1,"stats":{"Line":1}},{"line":302,"address":[5843247],"length":1,"stats":{"Line":1}},{"line":307,"address":[5844400],"length":1,"stats":{"Line":0}},{"line":308,"address":[5844413],"length":1,"stats":{"Line":1}},{"line":309,"address":[5844419],"length":1,"stats":{"Line":1}},{"line":310,"address":[5844426],"length":1,"stats":{"Line":1}},{"line":311,"address":[5844448],"length":1,"stats":{"Line":1}},{"line":315,"address":[5844512],"length":1,"stats":{"Line":0}},{"line":316,"address":[5844525],"length":1,"stats":{"Line":1}},{"line":317,"address":[5920240],"length":1,"stats":{"Line":1}},{"line":318,"address":[5844538],"length":1,"stats":{"Line":1}},{"line":319,"address":[5844560],"length":1,"stats":{"Line":1}},{"line":320,"address":[5844625],"length":1,"stats":{"Line":1}},{"line":325,"address":[5844379,5843808],"length":1,"stats":{"Line":1}},{"line":326,"address":[5843825],"length":1,"stats":{"Line":1}},{"line":327,"address":[5843832,5843847],"length":1,"stats":{"Line":2}},{"line":328,"address":[5844075,5844287,5844002],"length":1,"stats":{"Line":2}},{"line":330,"address":[5844112,5843853],"length":1,"stats":{"Line":1}},{"line":332,"address":[5843866],"length":1,"stats":{"Line":1}},{"line":333,"address":[5843889],"length":1,"stats":{"Line":1}},{"line":340,"address":[5843792],"length":1,"stats":{"Line":1}},{"line":341,"address":[5843799],"length":1,"stats":{"Line":1}},{"line":346,"address":[5844480],"length":1,"stats":{"Line":0}},{"line":347,"address":[5844493],"length":1,"stats":{"Line":1}},{"line":353,"address":[5843040],"length":1,"stats":{"Line":0}},{"line":354,"address":[5818274],"length":1,"stats":{"Line":1}}],"covered":38,"coverable":51},{"path":["/","home","user","jeeves-core","src","lib.rs"],"content":"//! # Jeeves Core - Multi-Agent Orchestration Kernel\n//!\n//! Rust implementation of the Jeeves kernel providing:\n//! - Process lifecycle management with Unix-like state transitions\n//! - Resource quota enforcement (LLM calls, tokens, hops, iterations)\n//! - Rate limiting with configurable windows\n//! - Flow interrupts for human-in-the-loop patterns\n//! - gRPC service layer for external clients\n//! - Message bus for pub/sub and request/response patterns\n//!\n//! ## Architecture\n//!\n//! The kernel follows a single-actor model where the `Kernel` owns all mutable state:\n//! ```text\n//!                    ┌─────────────────────────────────┐\n//!   gRPC requests →  │         Kernel Actor            │\n//!                    │  ┌─────────┐ ┌─────────┐        │\n//!                    │  │Resources│ │Lifecycle│        │\n//!                    │  │ Tracker │ │ Manager │        │\n//!                    │  └─────────┘ └─────────┘        │\n//!                    │  ┌─────────┐ ┌─────────┐        │\n//!                    │  │Interrupt│ │RateLimit│        │\n//!                    │  │ Service │ │   er    │        │\n//!                    │  └─────────┘ └─────────┘        │\n//!                    └─────────────────────────────────┘\n//! ```\n\n// Enforce strict safety at compile time\n#![deny(unsafe_code)]\n#![warn(missing_debug_implementations)]\n#![warn(rust_2018_idioms)]\n\n// Re-export public API\npub mod commbus;\npub mod envelope;\npub mod grpc;\npub mod kernel;\npub mod proto;\npub mod types;\n\n// Internal utilities\npub mod observability;\nmod validation;\n\npub use types::{Config, Error, Result};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","jeeves-core","src","main.rs"],"content":"//! Jeeves kernel gRPC server - main entry point.\n//!\n//! Starts a gRPC server with all 4 services:\n//! - KernelService: Process lifecycle and resource management\n//! - EngineService: Envelope operations\n//! - OrchestrationService: Kernel-driven pipeline execution\n//! - CommBusService: Message bus operations\n\nuse jeeves_core::Config;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\nuse tonic::transport::Server;\n\n// Import service implementations\nuse jeeves_core::grpc::{\n    CommBusService, EngineService, KernelServiceImpl, OrchestrationService,\n};\nuse jeeves_core::kernel::Kernel;\n\n// Import generated proto server traits\nuse jeeves_core::proto::comm_bus_service_server::CommBusServiceServer;\nuse jeeves_core::proto::engine_service_server::EngineServiceServer;\nuse jeeves_core::proto::kernel_service_server::KernelServiceServer;\nuse jeeves_core::proto::orchestration_service_server::OrchestrationServiceServer;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Load configuration\n    let _config = Config::default();\n\n    // Initialize observability\n    jeeves_core::observability::init_tracing();\n\n    // Create shared kernel instance (all services share one kernel)\n    let kernel = Arc::new(Mutex::new(Kernel::new()));\n\n    // Create all 4 gRPC services sharing the same kernel\n    let kernel_service = KernelServiceImpl::new(kernel.clone());\n    let engine_service = EngineService::new(kernel.clone());\n    let orchestration_service = OrchestrationService::new(kernel.clone());\n    let commbus_service = CommBusService::new(kernel.clone());\n\n    // Bind address\n    let addr = \"[::1]:50051\".parse()?;\n\n    tracing::info!(\"🚀 Jeeves Kernel gRPC server starting on {}\", addr);\n    tracing::info!(\"  ✓ KernelService: Process lifecycle and resources\");\n    tracing::info!(\"  ✓ EngineService: Envelope operations\");\n    tracing::info!(\"  ✓ OrchestrationService: Kernel-driven execution\");\n    tracing::info!(\"  ✓ CommBusService: Message bus\");\n\n    // Build and start gRPC server\n    Server::builder()\n        .add_service(KernelServiceServer::new(kernel_service))\n        .add_service(EngineServiceServer::new(engine_service))\n        .add_service(OrchestrationServiceServer::new(orchestration_service))\n        .add_service(CommBusServiceServer::new(commbus_service))\n        .serve(addr)\n        .await?;\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","jeeves-core","src","observability.rs"],"content":"//! Observability utilities (tracing and metrics).\n\n/// Initialize tracing subscriber (checkpoint 2).\npub fn init_tracing() {\n    // TODO: Implement in checkpoint 2\n}\n\n/// Initialize metrics (checkpoint 4).\npub fn init_metrics() {\n    // TODO: Implement in checkpoint 4\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","jeeves-core","src","types","config.rs"],"content":"//! Configuration structures.\n//!\n//! Configuration is loaded from environment variables and config files.\n\nuse serde::{Deserialize, Serialize};\nuse std::time::Duration;\n\n/// Global kernel configuration.\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct Config {\n    /// Server configuration.\n    #[serde(default)]\n    pub server: ServerConfig,\n\n    /// Observability configuration.\n    #[serde(default)]\n    pub observability: ObservabilityConfig,\n\n    /// Default resource limits.\n    #[serde(default)]\n    pub defaults: DefaultLimits,\n}\n\n/// Server configuration.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ServerConfig {\n    /// gRPC server bind address.\n    pub grpc_addr: String,\n\n    /// Metrics endpoint bind address.\n    pub metrics_addr: String,\n\n    /// Maximum concurrent connections.\n    pub max_connections: usize,\n}\n\nimpl Default for ServerConfig {\n    fn default() -\u003e Self {\n        Self {\n            grpc_addr: \"127.0.0.1:50051\".to_string(),\n            metrics_addr: \"127.0.0.1:9090\".to_string(),\n            max_connections: 1000,\n        }\n    }\n}\n\n/// Observability configuration.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ObservabilityConfig {\n    /// Tracing log level (trace, debug, info, warn, error).\n    pub log_level: String,\n\n    /// Enable JSON log formatting.\n    pub json_logs: bool,\n\n    /// OTLP exporter endpoint (optional).\n    pub otlp_endpoint: Option\u003cString\u003e,\n}\n\nimpl Default for ObservabilityConfig {\n    fn default() -\u003e Self {\n        Self {\n            log_level: \"info\".to_string(),\n            json_logs: false,\n            otlp_endpoint: None,\n        }\n    }\n}\n\n/// Default resource limits.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DefaultLimits {\n    /// Maximum LLM calls per envelope.\n    pub max_llm_calls: u32,\n\n    /// Maximum tool calls per envelope.\n    pub max_tool_calls: u32,\n\n    /// Maximum agent hops per envelope.\n    pub max_agent_hops: u32,\n\n    /// Maximum iterations per envelope.\n    pub max_iterations: u32,\n\n    /// Default process timeout.\n    #[serde(with = \"humantime_serde\")]\n    pub process_timeout: Duration,\n}\n\nimpl Default for DefaultLimits {\n    fn default() -\u003e Self {\n        Self {\n            max_llm_calls: 100,\n            max_tool_calls: 50,\n            max_agent_hops: 10,\n            max_iterations: 20,\n            process_timeout: Duration::from_secs(300),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","jeeves-core","src","types","errors.rs"],"content":"//! Application error types.\n//!\n//! All errors use `thiserror` for automatic Error trait derivation and provide\n//! clear error messages with context.\n\nuse thiserror::Error;\n\n/// Application result type.\npub type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\n\n/// Main error enum for the Jeeves kernel.\n#[derive(Error, Debug)]\npub enum Error {\n    /// Validation errors (map to gRPC INVALID_ARGUMENT).\n    #[error(\"validation error: {0}\")]\n    Validation(String),\n\n    /// Resource not found (map to gRPC NOT_FOUND).\n    #[error(\"not found: {0}\")]\n    NotFound(String),\n\n    /// Quota or resource exhaustion (map to gRPC RESOURCE_EXHAUSTED).\n    #[error(\"quota exceeded: {0}\")]\n    QuotaExceeded(String),\n\n    /// Invalid state transition (map to gRPC FAILED_PRECONDITION).\n    #[error(\"state transition error: {0}\")]\n    StateTransition(String),\n\n    /// Internal errors (map to gRPC INTERNAL).\n    #[error(\"internal error: {0}\")]\n    Internal(String),\n\n    /// Cancellation/timeout (map to gRPC CANCELLED or DEADLINE_EXCEEDED).\n    #[error(\"operation cancelled: {0}\")]\n    Cancelled(String),\n\n    /// Serialization/deserialization errors.\n    #[error(\"serialization error: {0}\")]\n    Serialization(#[from] serde_json::Error),\n\n    /// gRPC transport errors (boxed to reduce Result size).\n    #[error(\"grpc error: {0}\")]\n    Grpc(#[from] Box\u003ctonic::Status\u003e),\n\n    /// I/O errors.\n    #[error(\"io error: {0}\")]\n    Io(#[from] std::io::Error),\n}\n\nimpl Error {\n    /// Convert to gRPC status code.\n    pub fn to_grpc_status(\u0026self) -\u003e tonic::Status {\n        match self {\n            Error::Validation(msg) =\u003e {\n                tonic::Status::invalid_argument(msg)\n            }\n            Error::NotFound(msg) =\u003e {\n                tonic::Status::not_found(msg)\n            }\n            Error::QuotaExceeded(msg) =\u003e {\n                tonic::Status::resource_exhausted(msg)\n            }\n            Error::StateTransition(msg) =\u003e {\n                tonic::Status::failed_precondition(msg)\n            }\n            Error::Cancelled(msg) =\u003e {\n                tonic::Status::cancelled(msg)\n            }\n            Error::Internal(msg) =\u003e {\n                tonic::Status::internal(msg)\n            }\n            Error::Serialization(e) =\u003e {\n                tonic::Status::internal(format!(\"serialization error: {}\", e))\n            }\n            Error::Grpc(status) =\u003e (**status).clone(),\n            Error::Io(e) =\u003e {\n                tonic::Status::internal(format!(\"io error: {}\", e))\n            }\n        }\n    }\n}\n\n// Convenience constructors\nimpl Error {\n    pub fn validation(msg: impl Into\u003cString\u003e) -\u003e Self {\n        Self::Validation(msg.into())\n    }\n\n    pub fn not_found(msg: impl Into\u003cString\u003e) -\u003e Self {\n        Self::NotFound(msg.into())\n    }\n\n    pub fn quota_exceeded(msg: impl Into\u003cString\u003e) -\u003e Self {\n        Self::QuotaExceeded(msg.into())\n    }\n\n    pub fn state_transition(msg: impl Into\u003cString\u003e) -\u003e Self {\n        Self::StateTransition(msg.into())\n    }\n\n    pub fn internal(msg: impl Into\u003cString\u003e) -\u003e Self {\n        Self::Internal(msg.into())\n    }\n\n    pub fn cancelled(msg: impl Into\u003cString\u003e) -\u003e Self {\n        Self::Cancelled(msg.into())\n    }\n}\n\n// Implement From\u003cError\u003e for Status to enable ? operator in gRPC handlers\nimpl From\u003cError\u003e for tonic::Status {\n    fn from(err: Error) -\u003e Self {\n        err.to_grpc_status()\n    }\n}\n","traces":[{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[5824048],"length":1,"stats":{"Line":0}},{"line":91,"address":[5824052],"length":1,"stats":{"Line":8}},{"line":94,"address":[5823952],"length":1,"stats":{"Line":0}},{"line":95,"address":[5818494],"length":1,"stats":{"Line":3}},{"line":98,"address":[5824000],"length":1,"stats":{"Line":0}},{"line":99,"address":[5824004],"length":1,"stats":{"Line":3}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}}],"covered":3,"coverable":12},{"path":["/","home","user","jeeves-core","src","types","ids.rs"],"content":"//! Strongly-typed identifiers.\n//!\n//! All IDs are validated at construction time and implement common traits.\n\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// Process identifier (UUID v4).\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct ProcessId(String);\n\nimpl ProcessId {\n    pub fn new() -\u003e Self {\n        Self(uuid::Uuid::new_v4().to_string())\n    }\n\n    pub fn from_string(s: String) -\u003e Result\u003cSelf, \u0026'static str\u003e {\n        if s.is_empty() {\n            return Err(\"ProcessId cannot be empty\");\n        }\n        Ok(Self(s))\n    }\n\n    pub fn as_str(\u0026self) -\u003e \u0026str {\n        \u0026self.0\n    }\n}\n\nimpl Default for ProcessId {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl fmt::Display for ProcessId {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Envelope identifier (UUID v4).\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct EnvelopeId(String);\n\nimpl EnvelopeId {\n    pub fn new() -\u003e Self {\n        Self(uuid::Uuid::new_v4().to_string())\n    }\n\n    pub fn from_string(s: String) -\u003e Result\u003cSelf, \u0026'static str\u003e {\n        if s.is_empty() {\n            return Err(\"EnvelopeId cannot be empty\");\n        }\n        Ok(Self(s))\n    }\n\n    pub fn as_str(\u0026self) -\u003e \u0026str {\n        \u0026self.0\n    }\n}\n\nimpl Default for EnvelopeId {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl fmt::Display for EnvelopeId {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Request identifier (UUID v4).\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct RequestId(String);\n\nimpl RequestId {\n    pub fn new() -\u003e Self {\n        Self(uuid::Uuid::new_v4().to_string())\n    }\n\n    pub fn from_string(s: String) -\u003e Result\u003cSelf, \u0026'static str\u003e {\n        if s.is_empty() {\n            return Err(\"RequestId cannot be empty\");\n        }\n        Ok(Self(s))\n    }\n\n    pub fn as_str(\u0026self) -\u003e \u0026str {\n        \u0026self.0\n    }\n}\n\nimpl Default for RequestId {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl fmt::Display for RequestId {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Session identifier.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct SessionId(String);\n\nimpl SessionId {\n    pub fn new() -\u003e Self {\n        Self(uuid::Uuid::new_v4().to_string())\n    }\n\n    pub fn from_string(s: String) -\u003e Result\u003cSelf, \u0026'static str\u003e {\n        if s.is_empty() {\n            return Err(\"SessionId cannot be empty\");\n        }\n        Ok(Self(s))\n    }\n\n    pub fn as_str(\u0026self) -\u003e \u0026str {\n        \u0026self.0\n    }\n}\n\nimpl Default for SessionId {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl fmt::Display for SessionId {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// User identifier.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct UserId(String);\n\nimpl UserId {\n    pub fn from_string(s: String) -\u003e Result\u003cSelf, \u0026'static str\u003e {\n        if s.is_empty() {\n            return Err(\"UserId cannot be empty\");\n        }\n        Ok(Self(s))\n    }\n\n    pub fn as_str(\u0026self) -\u003e \u0026str {\n        \u0026self.0\n    }\n}\n\nimpl fmt::Display for UserId {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","jeeves-core","src","types","mod.rs"],"content":"//! Core types for the Jeeves kernel.\n//!\n//! This module provides foundational types used throughout the system:\n//! - **IDs**: Strongly-typed identifiers (ProcessId, EnvelopeId, etc.)\n//! - **Errors**: Application error types with thiserror derives\n//! - **Config**: Configuration structures for kernel, pipeline, and resources\n\nmod config;\nmod errors;\nmod ids;\n\npub use config::Config;\npub use errors::{Error, Result};\npub use ids::{EnvelopeId, ProcessId, RequestId, SessionId, UserId};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","jeeves-core","src","validation.rs"],"content":"//! Request validation utilities.\n\n// Allow dead code - these will be used in Phase 4 when implementing gRPC services\n#![allow(dead_code)]\n\n/// Validate that a string is not empty.\npub fn validate_non_empty(s: \u0026str, field: \u0026str) -\u003e crate::types::Result\u003c()\u003e {\n    if s.is_empty() {\n        return Err(crate::types::Error::validation(format!(\n            \"{} cannot be empty\",\n            field\n        )));\n    }\n    Ok(())\n}\n\n/// Validate that a value is positive.\npub fn validate_positive(n: u32, field: \u0026str) -\u003e crate::types::Result\u003c()\u003e {\n    if n == 0 {\n        return Err(crate::types::Error::validation(format!(\n            \"{} must be positive\",\n            field\n        )));\n    }\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, '🌙'),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      const nbHit = covered? trace.stats.Line: 0;
      return e(
        'div',
        { className: 'code-text-container' },
        e(
          'code',
          {
            className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          },
          line
        ),
        e(
          'div',
          { className: 'cover-indicator' + (covered? ' check-cover': '') + (uncovered? ' no-cover': '')},
          e(
            'div',
            { className: (covered? 'stat-line-hit': '')},
            covered? nbHit: ""
          )
        )
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = '🌙';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '☀️';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = '🌙';
    }
  });
})();
</script>
</body>
</html>