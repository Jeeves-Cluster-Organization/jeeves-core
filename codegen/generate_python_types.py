"""Generate Python enum definitions from Rust source files.

Reads Rust enum definitions with serde attributes from:
  - src/envelope/enums.rs (TerminalReason, InterruptKind, RiskSemantic, etc.)
  - src/kernel/interrupts.rs (InterruptStatus)

Outputs: python/jeeves_infra/protocols/_generated.py

Usage:
    cd jeeves-core
    python codegen/generate_python_types.py

The generated file is checked in. Run this script whenever Rust enums change.
CI should verify the generated file is up-to-date (no uncommitted diff).
"""

import re
import sys
from pathlib import Path

JEEVES_CORE_ROOT = Path(__file__).resolve().parent.parent

# Rust source files containing enums to generate
RUST_SOURCES = [
    ("src/envelope/enums.rs", [
        "TerminalReason",
        "InterruptKind",
        "RiskSemantic",
        "RiskSeverity",
        "ToolCategory",
        "HealthStatus",
        "LoopVerdict",
        "RiskApproval",
        "ToolAccess",
        "OperationStatus",
    ]),
    ("src/kernel/interrupts.rs", [
        "InterruptStatus",
    ]),
]

OUTPUT_FILE = JEEVES_CORE_ROOT / "python" / "jeeves_infra" / "protocols" / "_generated.py"


def parse_serde_rename_all(source: str, enum_name: str) -> str:
    """Extract the serde rename_all strategy for an enum."""
    # Find the enum definition and look at the preceding serde attribute
    pattern = rf'#\[serde\(rename_all\s*=\s*"([^"]+)"\)\]\s*pub enum {enum_name}'
    match = re.search(pattern, source)
    if not match:
        raise ValueError(
            f"Could not find #[serde(rename_all = \"...\")] for enum {enum_name}"
        )
    return match.group(1)


def parse_rust_enum_variants(source: str, enum_name: str) -> list[str]:
    """Extract PascalCase variant names from a Rust enum definition."""
    pattern = rf"pub enum {enum_name}\s*\{{([^}}]*)\}}"
    match = re.search(pattern, source, re.DOTALL)
    if not match:
        raise ValueError(f"Rust enum {enum_name} not found")
    body = match.group(1)
    variants = []
    for line in body.splitlines():
        line = line.split("//")[0].strip()  # strip comments
        if not line or line.startswith("#"):
            continue
        variant = line.rstrip(",").split("(")[0].strip()
        if variant and variant[0].isupper():
            variants.append(variant)
    return variants


def pascal_to_wire(variant: str, strategy: str) -> str:
    """Convert Rust PascalCase variant to serde wire format."""
    # Insert underscore before uppercase letters (except the first)
    snake = re.sub(r"([a-z0-9])([A-Z])", r"\1_\2", variant)
    if strategy == "SCREAMING_SNAKE_CASE":
        return snake.upper()
    elif strategy == "snake_case":
        return snake.lower()
    elif strategy == "lowercase":
        return variant.lower()
    return variant


def generate_enum_class(enum_name: str, variants: list[str], strategy: str) -> str:
    """Generate a Python str(Enum) class definition."""
    lines = [f"class {enum_name}(str, Enum):"]
    wire_values = [(v, pascal_to_wire(v, strategy)) for v in variants]
    for variant, wire in wire_values:
        # Python member name: SCREAMING_SNAKE_CASE for consistency
        py_name = re.sub(r"([a-z0-9])([A-Z])", r"\1_\2", variant).upper()
        lines.append(f'    {py_name} = "{wire}"')
    return "\n".join(lines)


def rust_doc_comment(source: str, enum_name: str) -> str:
    """Extract the doc comment above a Rust enum."""
    pattern = rf"((?:///[^\n]*\n)+)\s*#\[derive"
    # Find all doc comments, then match the one before our enum
    full_pattern = rf"((?:///[^\n]*\n)+)\s*#\[derive[^]]*\]\s*(?:#\[serde[^]]*\]\s*)?pub enum {enum_name}"
    match = re.search(full_pattern, source)
    if match:
        doc_lines = match.group(1).strip().splitlines()
        return " ".join(line.lstrip("/ ").strip() for line in doc_lines)
    return ""


def main() -> int:
    enums: list[tuple[str, list[str], str, str]] = []  # (name, variants, strategy, doc)

    for rel_path, enum_names in RUST_SOURCES:
        rust_file = JEEVES_CORE_ROOT / rel_path
        if not rust_file.exists():
            print(f"ERROR: {rust_file} not found", file=sys.stderr)
            return 1
        source = rust_file.read_text(encoding="utf-8")

        for enum_name in enum_names:
            strategy = parse_serde_rename_all(source, enum_name)
            variants = parse_rust_enum_variants(source, enum_name)
            doc = rust_doc_comment(source, enum_name)
            if not variants:
                print(f"ERROR: No variants found for {enum_name}", file=sys.stderr)
                return 1
            enums.append((enum_name, variants, strategy, doc))

    # Generate output
    parts = [
        '"""Auto-generated Python enums from Rust source. DO NOT EDIT.',
        "",
        "Generated by: codegen/generate_python_types.py",
        "Source files:",
    ]
    for rel_path, _ in RUST_SOURCES:
        parts.append(f"  - {rel_path}")
    parts.append("")
    parts.append('Re-run: cd jeeves-core && python codegen/generate_python_types.py')
    parts.append('"""')
    parts.append("")
    parts.append("from enum import Enum")
    parts.append("")

    all_names = []
    for enum_name, variants, strategy, doc in enums:
        parts.append("")
        if doc:
            parts.append(f"# {doc}")
        parts.append(generate_enum_class(enum_name, variants, strategy))
        all_names.append(enum_name)

    parts.append("")
    parts.append("")
    parts.append("__all__ = [")
    for name in all_names:
        parts.append(f'    "{name}",')
    parts.append("]")
    parts.append("")

    output = "\n".join(parts)
    OUTPUT_FILE.write_text(output, encoding="utf-8")
    print(f"Generated {OUTPUT_FILE} with {len(enums)} enums")
    return 0


if __name__ == "__main__":
    sys.exit(main())
