// Engine gRPC Service - Python <-> Go runtime bridge
//
// This is the primary IPC mechanism between Python orchestration
// and Go execution engine. Replaces subprocess-based JSON IPC.
//
// Compile Go:
//   protoc --go_out=. --go-grpc_out=. coreengine/proto/engine.proto
//
// Compile Python:
//   python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. coreengine/proto/engine.proto

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.4
// source: coreengine/proto/engine.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	KernelService_CreateProcess_FullMethodName    = "/jeeves.engine.v1.KernelService/CreateProcess"
	KernelService_GetProcess_FullMethodName       = "/jeeves.engine.v1.KernelService/GetProcess"
	KernelService_ScheduleProcess_FullMethodName  = "/jeeves.engine.v1.KernelService/ScheduleProcess"
	KernelService_GetNextRunnable_FullMethodName  = "/jeeves.engine.v1.KernelService/GetNextRunnable"
	KernelService_TransitionState_FullMethodName  = "/jeeves.engine.v1.KernelService/TransitionState"
	KernelService_TerminateProcess_FullMethodName = "/jeeves.engine.v1.KernelService/TerminateProcess"
	KernelService_CheckQuota_FullMethodName       = "/jeeves.engine.v1.KernelService/CheckQuota"
	KernelService_RecordUsage_FullMethodName      = "/jeeves.engine.v1.KernelService/RecordUsage"
	KernelService_CheckRateLimit_FullMethodName   = "/jeeves.engine.v1.KernelService/CheckRateLimit"
	KernelService_ListProcesses_FullMethodName    = "/jeeves.engine.v1.KernelService/ListProcesses"
	KernelService_GetProcessCounts_FullMethodName = "/jeeves.engine.v1.KernelService/GetProcessCounts"
)

// KernelServiceClient is the client API for KernelService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// =============================================================================
// KernelService - Process lifecycle and resource management
// =============================================================================
type KernelServiceClient interface {
	// Process lifecycle
	CreateProcess(ctx context.Context, in *CreateProcessRequest, opts ...grpc.CallOption) (*ProcessControlBlock, error)
	GetProcess(ctx context.Context, in *GetProcessRequest, opts ...grpc.CallOption) (*ProcessControlBlock, error)
	ScheduleProcess(ctx context.Context, in *ScheduleProcessRequest, opts ...grpc.CallOption) (*ProcessControlBlock, error)
	GetNextRunnable(ctx context.Context, in *GetNextRunnableRequest, opts ...grpc.CallOption) (*ProcessControlBlock, error)
	TransitionState(ctx context.Context, in *TransitionStateRequest, opts ...grpc.CallOption) (*ProcessControlBlock, error)
	TerminateProcess(ctx context.Context, in *TerminateProcessRequest, opts ...grpc.CallOption) (*ProcessControlBlock, error)
	// Resource management
	CheckQuota(ctx context.Context, in *CheckQuotaRequest, opts ...grpc.CallOption) (*QuotaResult, error)
	RecordUsage(ctx context.Context, in *RecordUsageRequest, opts ...grpc.CallOption) (*ResourceUsage, error)
	CheckRateLimit(ctx context.Context, in *CheckRateLimitRequest, opts ...grpc.CallOption) (*RateLimitResult, error)
	// Queries
	ListProcesses(ctx context.Context, in *ListProcessesRequest, opts ...grpc.CallOption) (*ListProcessesResponse, error)
	GetProcessCounts(ctx context.Context, in *GetProcessCountsRequest, opts ...grpc.CallOption) (*ProcessCountsResponse, error)
}

type kernelServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewKernelServiceClient(cc grpc.ClientConnInterface) KernelServiceClient {
	return &kernelServiceClient{cc}
}

func (c *kernelServiceClient) CreateProcess(ctx context.Context, in *CreateProcessRequest, opts ...grpc.CallOption) (*ProcessControlBlock, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessControlBlock)
	err := c.cc.Invoke(ctx, KernelService_CreateProcess_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kernelServiceClient) GetProcess(ctx context.Context, in *GetProcessRequest, opts ...grpc.CallOption) (*ProcessControlBlock, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessControlBlock)
	err := c.cc.Invoke(ctx, KernelService_GetProcess_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kernelServiceClient) ScheduleProcess(ctx context.Context, in *ScheduleProcessRequest, opts ...grpc.CallOption) (*ProcessControlBlock, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessControlBlock)
	err := c.cc.Invoke(ctx, KernelService_ScheduleProcess_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kernelServiceClient) GetNextRunnable(ctx context.Context, in *GetNextRunnableRequest, opts ...grpc.CallOption) (*ProcessControlBlock, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessControlBlock)
	err := c.cc.Invoke(ctx, KernelService_GetNextRunnable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kernelServiceClient) TransitionState(ctx context.Context, in *TransitionStateRequest, opts ...grpc.CallOption) (*ProcessControlBlock, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessControlBlock)
	err := c.cc.Invoke(ctx, KernelService_TransitionState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kernelServiceClient) TerminateProcess(ctx context.Context, in *TerminateProcessRequest, opts ...grpc.CallOption) (*ProcessControlBlock, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessControlBlock)
	err := c.cc.Invoke(ctx, KernelService_TerminateProcess_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kernelServiceClient) CheckQuota(ctx context.Context, in *CheckQuotaRequest, opts ...grpc.CallOption) (*QuotaResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuotaResult)
	err := c.cc.Invoke(ctx, KernelService_CheckQuota_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kernelServiceClient) RecordUsage(ctx context.Context, in *RecordUsageRequest, opts ...grpc.CallOption) (*ResourceUsage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResourceUsage)
	err := c.cc.Invoke(ctx, KernelService_RecordUsage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kernelServiceClient) CheckRateLimit(ctx context.Context, in *CheckRateLimitRequest, opts ...grpc.CallOption) (*RateLimitResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RateLimitResult)
	err := c.cc.Invoke(ctx, KernelService_CheckRateLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kernelServiceClient) ListProcesses(ctx context.Context, in *ListProcessesRequest, opts ...grpc.CallOption) (*ListProcessesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProcessesResponse)
	err := c.cc.Invoke(ctx, KernelService_ListProcesses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kernelServiceClient) GetProcessCounts(ctx context.Context, in *GetProcessCountsRequest, opts ...grpc.CallOption) (*ProcessCountsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessCountsResponse)
	err := c.cc.Invoke(ctx, KernelService_GetProcessCounts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KernelServiceServer is the server API for KernelService service.
// All implementations must embed UnimplementedKernelServiceServer
// for forward compatibility.
//
// =============================================================================
// KernelService - Process lifecycle and resource management
// =============================================================================
type KernelServiceServer interface {
	// Process lifecycle
	CreateProcess(context.Context, *CreateProcessRequest) (*ProcessControlBlock, error)
	GetProcess(context.Context, *GetProcessRequest) (*ProcessControlBlock, error)
	ScheduleProcess(context.Context, *ScheduleProcessRequest) (*ProcessControlBlock, error)
	GetNextRunnable(context.Context, *GetNextRunnableRequest) (*ProcessControlBlock, error)
	TransitionState(context.Context, *TransitionStateRequest) (*ProcessControlBlock, error)
	TerminateProcess(context.Context, *TerminateProcessRequest) (*ProcessControlBlock, error)
	// Resource management
	CheckQuota(context.Context, *CheckQuotaRequest) (*QuotaResult, error)
	RecordUsage(context.Context, *RecordUsageRequest) (*ResourceUsage, error)
	CheckRateLimit(context.Context, *CheckRateLimitRequest) (*RateLimitResult, error)
	// Queries
	ListProcesses(context.Context, *ListProcessesRequest) (*ListProcessesResponse, error)
	GetProcessCounts(context.Context, *GetProcessCountsRequest) (*ProcessCountsResponse, error)
	mustEmbedUnimplementedKernelServiceServer()
}

// UnimplementedKernelServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedKernelServiceServer struct{}

func (UnimplementedKernelServiceServer) CreateProcess(context.Context, *CreateProcessRequest) (*ProcessControlBlock, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateProcess not implemented")
}
func (UnimplementedKernelServiceServer) GetProcess(context.Context, *GetProcessRequest) (*ProcessControlBlock, error) {
	return nil, status.Error(codes.Unimplemented, "method GetProcess not implemented")
}
func (UnimplementedKernelServiceServer) ScheduleProcess(context.Context, *ScheduleProcessRequest) (*ProcessControlBlock, error) {
	return nil, status.Error(codes.Unimplemented, "method ScheduleProcess not implemented")
}
func (UnimplementedKernelServiceServer) GetNextRunnable(context.Context, *GetNextRunnableRequest) (*ProcessControlBlock, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNextRunnable not implemented")
}
func (UnimplementedKernelServiceServer) TransitionState(context.Context, *TransitionStateRequest) (*ProcessControlBlock, error) {
	return nil, status.Error(codes.Unimplemented, "method TransitionState not implemented")
}
func (UnimplementedKernelServiceServer) TerminateProcess(context.Context, *TerminateProcessRequest) (*ProcessControlBlock, error) {
	return nil, status.Error(codes.Unimplemented, "method TerminateProcess not implemented")
}
func (UnimplementedKernelServiceServer) CheckQuota(context.Context, *CheckQuotaRequest) (*QuotaResult, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckQuota not implemented")
}
func (UnimplementedKernelServiceServer) RecordUsage(context.Context, *RecordUsageRequest) (*ResourceUsage, error) {
	return nil, status.Error(codes.Unimplemented, "method RecordUsage not implemented")
}
func (UnimplementedKernelServiceServer) CheckRateLimit(context.Context, *CheckRateLimitRequest) (*RateLimitResult, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckRateLimit not implemented")
}
func (UnimplementedKernelServiceServer) ListProcesses(context.Context, *ListProcessesRequest) (*ListProcessesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListProcesses not implemented")
}
func (UnimplementedKernelServiceServer) GetProcessCounts(context.Context, *GetProcessCountsRequest) (*ProcessCountsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetProcessCounts not implemented")
}
func (UnimplementedKernelServiceServer) mustEmbedUnimplementedKernelServiceServer() {}
func (UnimplementedKernelServiceServer) testEmbeddedByValue()                       {}

// UnsafeKernelServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KernelServiceServer will
// result in compilation errors.
type UnsafeKernelServiceServer interface {
	mustEmbedUnimplementedKernelServiceServer()
}

func RegisterKernelServiceServer(s grpc.ServiceRegistrar, srv KernelServiceServer) {
	// If the following call panics, it indicates UnimplementedKernelServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&KernelService_ServiceDesc, srv)
}

func _KernelService_CreateProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KernelServiceServer).CreateProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KernelService_CreateProcess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KernelServiceServer).CreateProcess(ctx, req.(*CreateProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KernelService_GetProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KernelServiceServer).GetProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KernelService_GetProcess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KernelServiceServer).GetProcess(ctx, req.(*GetProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KernelService_ScheduleProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduleProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KernelServiceServer).ScheduleProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KernelService_ScheduleProcess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KernelServiceServer).ScheduleProcess(ctx, req.(*ScheduleProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KernelService_GetNextRunnable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNextRunnableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KernelServiceServer).GetNextRunnable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KernelService_GetNextRunnable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KernelServiceServer).GetNextRunnable(ctx, req.(*GetNextRunnableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KernelService_TransitionState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransitionStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KernelServiceServer).TransitionState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KernelService_TransitionState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KernelServiceServer).TransitionState(ctx, req.(*TransitionStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KernelService_TerminateProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminateProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KernelServiceServer).TerminateProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KernelService_TerminateProcess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KernelServiceServer).TerminateProcess(ctx, req.(*TerminateProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KernelService_CheckQuota_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckQuotaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KernelServiceServer).CheckQuota(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KernelService_CheckQuota_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KernelServiceServer).CheckQuota(ctx, req.(*CheckQuotaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KernelService_RecordUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordUsageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KernelServiceServer).RecordUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KernelService_RecordUsage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KernelServiceServer).RecordUsage(ctx, req.(*RecordUsageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KernelService_CheckRateLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckRateLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KernelServiceServer).CheckRateLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KernelService_CheckRateLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KernelServiceServer).CheckRateLimit(ctx, req.(*CheckRateLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KernelService_ListProcesses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProcessesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KernelServiceServer).ListProcesses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KernelService_ListProcesses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KernelServiceServer).ListProcesses(ctx, req.(*ListProcessesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KernelService_GetProcessCounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProcessCountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KernelServiceServer).GetProcessCounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KernelService_GetProcessCounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KernelServiceServer).GetProcessCounts(ctx, req.(*GetProcessCountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// KernelService_ServiceDesc is the grpc.ServiceDesc for KernelService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KernelService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "jeeves.engine.v1.KernelService",
	HandlerType: (*KernelServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProcess",
			Handler:    _KernelService_CreateProcess_Handler,
		},
		{
			MethodName: "GetProcess",
			Handler:    _KernelService_GetProcess_Handler,
		},
		{
			MethodName: "ScheduleProcess",
			Handler:    _KernelService_ScheduleProcess_Handler,
		},
		{
			MethodName: "GetNextRunnable",
			Handler:    _KernelService_GetNextRunnable_Handler,
		},
		{
			MethodName: "TransitionState",
			Handler:    _KernelService_TransitionState_Handler,
		},
		{
			MethodName: "TerminateProcess",
			Handler:    _KernelService_TerminateProcess_Handler,
		},
		{
			MethodName: "CheckQuota",
			Handler:    _KernelService_CheckQuota_Handler,
		},
		{
			MethodName: "RecordUsage",
			Handler:    _KernelService_RecordUsage_Handler,
		},
		{
			MethodName: "CheckRateLimit",
			Handler:    _KernelService_CheckRateLimit_Handler,
		},
		{
			MethodName: "ListProcesses",
			Handler:    _KernelService_ListProcesses_Handler,
		},
		{
			MethodName: "GetProcessCounts",
			Handler:    _KernelService_GetProcessCounts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "coreengine/proto/engine.proto",
}

const (
	EngineService_CreateEnvelope_FullMethodName  = "/jeeves.engine.v1.EngineService/CreateEnvelope"
	EngineService_UpdateEnvelope_FullMethodName  = "/jeeves.engine.v1.EngineService/UpdateEnvelope"
	EngineService_CheckBounds_FullMethodName     = "/jeeves.engine.v1.EngineService/CheckBounds"
	EngineService_ExecutePipeline_FullMethodName = "/jeeves.engine.v1.EngineService/ExecutePipeline"
	EngineService_ExecuteAgent_FullMethodName    = "/jeeves.engine.v1.EngineService/ExecuteAgent"
	EngineService_CloneEnvelope_FullMethodName   = "/jeeves.engine.v1.EngineService/CloneEnvelope"
)

// EngineServiceClient is the client API for EngineService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// =============================================================================
// EngineService - Go runtime operations
// =============================================================================
type EngineServiceClient interface {
	// Envelope lifecycle
	CreateEnvelope(ctx context.Context, in *CreateEnvelopeRequest, opts ...grpc.CallOption) (*Envelope, error)
	UpdateEnvelope(ctx context.Context, in *UpdateEnvelopeRequest, opts ...grpc.CallOption) (*Envelope, error)
	// Bounds checking (Go is authoritative)
	CheckBounds(ctx context.Context, in *Envelope, opts ...grpc.CallOption) (*BoundsResult, error)
	// Execution
	ExecutePipeline(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecutionEvent], error)
	ExecuteAgent(ctx context.Context, in *ExecuteAgentRequest, opts ...grpc.CallOption) (*AgentResult, error)
	// State management
	CloneEnvelope(ctx context.Context, in *CloneRequest, opts ...grpc.CallOption) (*Envelope, error)
}

type engineServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEngineServiceClient(cc grpc.ClientConnInterface) EngineServiceClient {
	return &engineServiceClient{cc}
}

func (c *engineServiceClient) CreateEnvelope(ctx context.Context, in *CreateEnvelopeRequest, opts ...grpc.CallOption) (*Envelope, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Envelope)
	err := c.cc.Invoke(ctx, EngineService_CreateEnvelope_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *engineServiceClient) UpdateEnvelope(ctx context.Context, in *UpdateEnvelopeRequest, opts ...grpc.CallOption) (*Envelope, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Envelope)
	err := c.cc.Invoke(ctx, EngineService_UpdateEnvelope_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *engineServiceClient) CheckBounds(ctx context.Context, in *Envelope, opts ...grpc.CallOption) (*BoundsResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoundsResult)
	err := c.cc.Invoke(ctx, EngineService_CheckBounds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *engineServiceClient) ExecutePipeline(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecutionEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &EngineService_ServiceDesc.Streams[0], EngineService_ExecutePipeline_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExecuteRequest, ExecutionEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EngineService_ExecutePipelineClient = grpc.ServerStreamingClient[ExecutionEvent]

func (c *engineServiceClient) ExecuteAgent(ctx context.Context, in *ExecuteAgentRequest, opts ...grpc.CallOption) (*AgentResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentResult)
	err := c.cc.Invoke(ctx, EngineService_ExecuteAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *engineServiceClient) CloneEnvelope(ctx context.Context, in *CloneRequest, opts ...grpc.CallOption) (*Envelope, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Envelope)
	err := c.cc.Invoke(ctx, EngineService_CloneEnvelope_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EngineServiceServer is the server API for EngineService service.
// All implementations must embed UnimplementedEngineServiceServer
// for forward compatibility.
//
// =============================================================================
// EngineService - Go runtime operations
// =============================================================================
type EngineServiceServer interface {
	// Envelope lifecycle
	CreateEnvelope(context.Context, *CreateEnvelopeRequest) (*Envelope, error)
	UpdateEnvelope(context.Context, *UpdateEnvelopeRequest) (*Envelope, error)
	// Bounds checking (Go is authoritative)
	CheckBounds(context.Context, *Envelope) (*BoundsResult, error)
	// Execution
	ExecutePipeline(*ExecuteRequest, grpc.ServerStreamingServer[ExecutionEvent]) error
	ExecuteAgent(context.Context, *ExecuteAgentRequest) (*AgentResult, error)
	// State management
	CloneEnvelope(context.Context, *CloneRequest) (*Envelope, error)
	mustEmbedUnimplementedEngineServiceServer()
}

// UnimplementedEngineServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEngineServiceServer struct{}

func (UnimplementedEngineServiceServer) CreateEnvelope(context.Context, *CreateEnvelopeRequest) (*Envelope, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateEnvelope not implemented")
}
func (UnimplementedEngineServiceServer) UpdateEnvelope(context.Context, *UpdateEnvelopeRequest) (*Envelope, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateEnvelope not implemented")
}
func (UnimplementedEngineServiceServer) CheckBounds(context.Context, *Envelope) (*BoundsResult, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckBounds not implemented")
}
func (UnimplementedEngineServiceServer) ExecutePipeline(*ExecuteRequest, grpc.ServerStreamingServer[ExecutionEvent]) error {
	return status.Error(codes.Unimplemented, "method ExecutePipeline not implemented")
}
func (UnimplementedEngineServiceServer) ExecuteAgent(context.Context, *ExecuteAgentRequest) (*AgentResult, error) {
	return nil, status.Error(codes.Unimplemented, "method ExecuteAgent not implemented")
}
func (UnimplementedEngineServiceServer) CloneEnvelope(context.Context, *CloneRequest) (*Envelope, error) {
	return nil, status.Error(codes.Unimplemented, "method CloneEnvelope not implemented")
}
func (UnimplementedEngineServiceServer) mustEmbedUnimplementedEngineServiceServer() {}
func (UnimplementedEngineServiceServer) testEmbeddedByValue()                       {}

// UnsafeEngineServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EngineServiceServer will
// result in compilation errors.
type UnsafeEngineServiceServer interface {
	mustEmbedUnimplementedEngineServiceServer()
}

func RegisterEngineServiceServer(s grpc.ServiceRegistrar, srv EngineServiceServer) {
	// If the following call panics, it indicates UnimplementedEngineServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EngineService_ServiceDesc, srv)
}

func _EngineService_CreateEnvelope_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateEnvelopeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineServiceServer).CreateEnvelope(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EngineService_CreateEnvelope_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineServiceServer).CreateEnvelope(ctx, req.(*CreateEnvelopeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EngineService_UpdateEnvelope_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateEnvelopeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineServiceServer).UpdateEnvelope(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EngineService_UpdateEnvelope_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineServiceServer).UpdateEnvelope(ctx, req.(*UpdateEnvelopeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EngineService_CheckBounds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Envelope)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineServiceServer).CheckBounds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EngineService_CheckBounds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineServiceServer).CheckBounds(ctx, req.(*Envelope))
	}
	return interceptor(ctx, in, info, handler)
}

func _EngineService_ExecutePipeline_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecuteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EngineServiceServer).ExecutePipeline(m, &grpc.GenericServerStream[ExecuteRequest, ExecutionEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EngineService_ExecutePipelineServer = grpc.ServerStreamingServer[ExecutionEvent]

func _EngineService_ExecuteAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineServiceServer).ExecuteAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EngineService_ExecuteAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineServiceServer).ExecuteAgent(ctx, req.(*ExecuteAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EngineService_CloneEnvelope_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloneRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineServiceServer).CloneEnvelope(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EngineService_CloneEnvelope_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineServiceServer).CloneEnvelope(ctx, req.(*CloneRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EngineService_ServiceDesc is the grpc.ServiceDesc for EngineService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EngineService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "jeeves.engine.v1.EngineService",
	HandlerType: (*EngineServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateEnvelope",
			Handler:    _EngineService_CreateEnvelope_Handler,
		},
		{
			MethodName: "UpdateEnvelope",
			Handler:    _EngineService_UpdateEnvelope_Handler,
		},
		{
			MethodName: "CheckBounds",
			Handler:    _EngineService_CheckBounds_Handler,
		},
		{
			MethodName: "ExecuteAgent",
			Handler:    _EngineService_ExecuteAgent_Handler,
		},
		{
			MethodName: "CloneEnvelope",
			Handler:    _EngineService_CloneEnvelope_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ExecutePipeline",
			Handler:       _EngineService_ExecutePipeline_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "coreengine/proto/engine.proto",
}

const (
	CommBusService_Publish_FullMethodName   = "/jeeves.engine.v1.CommBusService/Publish"
	CommBusService_Send_FullMethodName      = "/jeeves.engine.v1.CommBusService/Send"
	CommBusService_Query_FullMethodName     = "/jeeves.engine.v1.CommBusService/Query"
	CommBusService_Subscribe_FullMethodName = "/jeeves.engine.v1.CommBusService/Subscribe"
)

// CommBusServiceClient is the client API for CommBusService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// =============================================================================
// CommBusService - Message bus operations (Agentic OS IPC)
// =============================================================================
type CommBusServiceClient interface {
	// Publish event to all subscribers (fire-and-forget, fan-out)
	Publish(ctx context.Context, in *CommBusPublishRequest, opts ...grpc.CallOption) (*CommBusPublishResponse, error)
	// Send command to single handler (fire-and-forget)
	Send(ctx context.Context, in *CommBusSendRequest, opts ...grpc.CallOption) (*CommBusSendResponse, error)
	// Query with response (request-response, synchronous)
	Query(ctx context.Context, in *CommBusQueryRequest, opts ...grpc.CallOption) (*CommBusQueryResponse, error)
	// Subscribe to events (server streaming)
	Subscribe(ctx context.Context, in *CommBusSubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CommBusEvent], error)
}

type commBusServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCommBusServiceClient(cc grpc.ClientConnInterface) CommBusServiceClient {
	return &commBusServiceClient{cc}
}

func (c *commBusServiceClient) Publish(ctx context.Context, in *CommBusPublishRequest, opts ...grpc.CallOption) (*CommBusPublishResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommBusPublishResponse)
	err := c.cc.Invoke(ctx, CommBusService_Publish_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commBusServiceClient) Send(ctx context.Context, in *CommBusSendRequest, opts ...grpc.CallOption) (*CommBusSendResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommBusSendResponse)
	err := c.cc.Invoke(ctx, CommBusService_Send_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commBusServiceClient) Query(ctx context.Context, in *CommBusQueryRequest, opts ...grpc.CallOption) (*CommBusQueryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommBusQueryResponse)
	err := c.cc.Invoke(ctx, CommBusService_Query_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commBusServiceClient) Subscribe(ctx context.Context, in *CommBusSubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CommBusEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CommBusService_ServiceDesc.Streams[0], CommBusService_Subscribe_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[CommBusSubscribeRequest, CommBusEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CommBusService_SubscribeClient = grpc.ServerStreamingClient[CommBusEvent]

// CommBusServiceServer is the server API for CommBusService service.
// All implementations must embed UnimplementedCommBusServiceServer
// for forward compatibility.
//
// =============================================================================
// CommBusService - Message bus operations (Agentic OS IPC)
// =============================================================================
type CommBusServiceServer interface {
	// Publish event to all subscribers (fire-and-forget, fan-out)
	Publish(context.Context, *CommBusPublishRequest) (*CommBusPublishResponse, error)
	// Send command to single handler (fire-and-forget)
	Send(context.Context, *CommBusSendRequest) (*CommBusSendResponse, error)
	// Query with response (request-response, synchronous)
	Query(context.Context, *CommBusQueryRequest) (*CommBusQueryResponse, error)
	// Subscribe to events (server streaming)
	Subscribe(*CommBusSubscribeRequest, grpc.ServerStreamingServer[CommBusEvent]) error
	mustEmbedUnimplementedCommBusServiceServer()
}

// UnimplementedCommBusServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCommBusServiceServer struct{}

func (UnimplementedCommBusServiceServer) Publish(context.Context, *CommBusPublishRequest) (*CommBusPublishResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Publish not implemented")
}
func (UnimplementedCommBusServiceServer) Send(context.Context, *CommBusSendRequest) (*CommBusSendResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedCommBusServiceServer) Query(context.Context, *CommBusQueryRequest) (*CommBusQueryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Query not implemented")
}
func (UnimplementedCommBusServiceServer) Subscribe(*CommBusSubscribeRequest, grpc.ServerStreamingServer[CommBusEvent]) error {
	return status.Error(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedCommBusServiceServer) mustEmbedUnimplementedCommBusServiceServer() {}
func (UnimplementedCommBusServiceServer) testEmbeddedByValue()                        {}

// UnsafeCommBusServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommBusServiceServer will
// result in compilation errors.
type UnsafeCommBusServiceServer interface {
	mustEmbedUnimplementedCommBusServiceServer()
}

func RegisterCommBusServiceServer(s grpc.ServiceRegistrar, srv CommBusServiceServer) {
	// If the following call panics, it indicates UnimplementedCommBusServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CommBusService_ServiceDesc, srv)
}

func _CommBusService_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommBusPublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommBusServiceServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommBusService_Publish_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommBusServiceServer).Publish(ctx, req.(*CommBusPublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommBusService_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommBusSendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommBusServiceServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommBusService_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommBusServiceServer).Send(ctx, req.(*CommBusSendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommBusService_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommBusQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommBusServiceServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommBusService_Query_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommBusServiceServer).Query(ctx, req.(*CommBusQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommBusService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CommBusSubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CommBusServiceServer).Subscribe(m, &grpc.GenericServerStream[CommBusSubscribeRequest, CommBusEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CommBusService_SubscribeServer = grpc.ServerStreamingServer[CommBusEvent]

// CommBusService_ServiceDesc is the grpc.ServiceDesc for CommBusService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CommBusService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "jeeves.engine.v1.CommBusService",
	HandlerType: (*CommBusServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Publish",
			Handler:    _CommBusService_Publish_Handler,
		},
		{
			MethodName: "Send",
			Handler:    _CommBusService_Send_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _CommBusService_Query_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _CommBusService_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "coreengine/proto/engine.proto",
}

const (
	OrchestrationService_InitializeSession_FullMethodName  = "/jeeves.engine.v1.OrchestrationService/InitializeSession"
	OrchestrationService_GetNextInstruction_FullMethodName = "/jeeves.engine.v1.OrchestrationService/GetNextInstruction"
	OrchestrationService_ReportAgentResult_FullMethodName  = "/jeeves.engine.v1.OrchestrationService/ReportAgentResult"
	OrchestrationService_GetSessionState_FullMethodName    = "/jeeves.engine.v1.OrchestrationService/GetSessionState"
)

// OrchestrationServiceClient is the client API for OrchestrationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// OrchestrationService moves pipeline orchestration from Python to Go kernel.
// Python workers ask the kernel for instructions, execute agents, and report results.
// The kernel owns: loop control, routing, bounds checking, state transitions.
type OrchestrationServiceClient interface {
	// Initialize a new orchestration session with pipeline config
	InitializeSession(ctx context.Context, in *InitializeSessionRequest, opts ...grpc.CallOption) (*SessionState, error)
	// Get the next instruction (what agent to run, or terminal state)
	GetNextInstruction(ctx context.Context, in *GetNextInstructionRequest, opts ...grpc.CallOption) (*Instruction, error)
	// Report agent execution result and get next instruction
	ReportAgentResult(ctx context.Context, in *ReportAgentResultRequest, opts ...grpc.CallOption) (*Instruction, error)
	// Get current session state (for debugging/recovery)
	GetSessionState(ctx context.Context, in *GetSessionStateRequest, opts ...grpc.CallOption) (*SessionState, error)
}

type orchestrationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOrchestrationServiceClient(cc grpc.ClientConnInterface) OrchestrationServiceClient {
	return &orchestrationServiceClient{cc}
}

func (c *orchestrationServiceClient) InitializeSession(ctx context.Context, in *InitializeSessionRequest, opts ...grpc.CallOption) (*SessionState, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SessionState)
	err := c.cc.Invoke(ctx, OrchestrationService_InitializeSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orchestrationServiceClient) GetNextInstruction(ctx context.Context, in *GetNextInstructionRequest, opts ...grpc.CallOption) (*Instruction, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Instruction)
	err := c.cc.Invoke(ctx, OrchestrationService_GetNextInstruction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orchestrationServiceClient) ReportAgentResult(ctx context.Context, in *ReportAgentResultRequest, opts ...grpc.CallOption) (*Instruction, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Instruction)
	err := c.cc.Invoke(ctx, OrchestrationService_ReportAgentResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orchestrationServiceClient) GetSessionState(ctx context.Context, in *GetSessionStateRequest, opts ...grpc.CallOption) (*SessionState, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SessionState)
	err := c.cc.Invoke(ctx, OrchestrationService_GetSessionState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OrchestrationServiceServer is the server API for OrchestrationService service.
// All implementations must embed UnimplementedOrchestrationServiceServer
// for forward compatibility.
//
// OrchestrationService moves pipeline orchestration from Python to Go kernel.
// Python workers ask the kernel for instructions, execute agents, and report results.
// The kernel owns: loop control, routing, bounds checking, state transitions.
type OrchestrationServiceServer interface {
	// Initialize a new orchestration session with pipeline config
	InitializeSession(context.Context, *InitializeSessionRequest) (*SessionState, error)
	// Get the next instruction (what agent to run, or terminal state)
	GetNextInstruction(context.Context, *GetNextInstructionRequest) (*Instruction, error)
	// Report agent execution result and get next instruction
	ReportAgentResult(context.Context, *ReportAgentResultRequest) (*Instruction, error)
	// Get current session state (for debugging/recovery)
	GetSessionState(context.Context, *GetSessionStateRequest) (*SessionState, error)
	mustEmbedUnimplementedOrchestrationServiceServer()
}

// UnimplementedOrchestrationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOrchestrationServiceServer struct{}

func (UnimplementedOrchestrationServiceServer) InitializeSession(context.Context, *InitializeSessionRequest) (*SessionState, error) {
	return nil, status.Error(codes.Unimplemented, "method InitializeSession not implemented")
}
func (UnimplementedOrchestrationServiceServer) GetNextInstruction(context.Context, *GetNextInstructionRequest) (*Instruction, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNextInstruction not implemented")
}
func (UnimplementedOrchestrationServiceServer) ReportAgentResult(context.Context, *ReportAgentResultRequest) (*Instruction, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportAgentResult not implemented")
}
func (UnimplementedOrchestrationServiceServer) GetSessionState(context.Context, *GetSessionStateRequest) (*SessionState, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSessionState not implemented")
}
func (UnimplementedOrchestrationServiceServer) mustEmbedUnimplementedOrchestrationServiceServer() {}
func (UnimplementedOrchestrationServiceServer) testEmbeddedByValue()                              {}

// UnsafeOrchestrationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OrchestrationServiceServer will
// result in compilation errors.
type UnsafeOrchestrationServiceServer interface {
	mustEmbedUnimplementedOrchestrationServiceServer()
}

func RegisterOrchestrationServiceServer(s grpc.ServiceRegistrar, srv OrchestrationServiceServer) {
	// If the following call panics, it indicates UnimplementedOrchestrationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&OrchestrationService_ServiceDesc, srv)
}

func _OrchestrationService_InitializeSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitializeSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrchestrationServiceServer).InitializeSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrchestrationService_InitializeSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrchestrationServiceServer).InitializeSession(ctx, req.(*InitializeSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrchestrationService_GetNextInstruction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNextInstructionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrchestrationServiceServer).GetNextInstruction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrchestrationService_GetNextInstruction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrchestrationServiceServer).GetNextInstruction(ctx, req.(*GetNextInstructionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrchestrationService_ReportAgentResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportAgentResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrchestrationServiceServer).ReportAgentResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrchestrationService_ReportAgentResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrchestrationServiceServer).ReportAgentResult(ctx, req.(*ReportAgentResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrchestrationService_GetSessionState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSessionStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrchestrationServiceServer).GetSessionState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrchestrationService_GetSessionState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrchestrationServiceServer).GetSessionState(ctx, req.(*GetSessionStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OrchestrationService_ServiceDesc is the grpc.ServiceDesc for OrchestrationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OrchestrationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "jeeves.engine.v1.OrchestrationService",
	HandlerType: (*OrchestrationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InitializeSession",
			Handler:    _OrchestrationService_InitializeSession_Handler,
		},
		{
			MethodName: "GetNextInstruction",
			Handler:    _OrchestrationService_GetNextInstruction_Handler,
		},
		{
			MethodName: "ReportAgentResult",
			Handler:    _OrchestrationService_ReportAgentResult_Handler,
		},
		{
			MethodName: "GetSessionState",
			Handler:    _OrchestrationService_GetSessionState_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "coreengine/proto/engine.proto",
}
